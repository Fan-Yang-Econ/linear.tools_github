{
    "collab_server" : "",
    "contents" : "# put this file in R folder of the package\n# run  roxygen2::roxygenise()\n\n### Test ---------------------\n\n# source(\"/Users/yangguodaxia/Dropbox/Tech/R/attach_Load_First.R\")\n# source(\"S:/Users/Fan Yang/Research/Core_Code/attach_Load_First.R\")\n# source(\"H:/jpmDesk/Desktop/Personal/Research_personal/Core_Code/linear_tools.R\"\n# source(\"/Users/yangguodaxia/Dropbox/Tech/R/linear_tools_origin.R\")\n\n\n# key problem is predict() cannot handle dirty formula, when the newdata does not contain empty vars in dirty formula\n# key finding is the name class() that can be transfered to call.\n\n#\nlibrary(magrittr)\nlibrary(ggplot2)\nlibrary(pryr)\nlibrary(plyr)\nlibrary(stringr)\nlibrary(scales)\n#  data.table(ggplot2::diamonds)\n\n\n###  Not Exported ==================\n\ncheck_names_delete = function(tobechecked, checking,\n                              STOP = TRUE,\n                              tobechecked_name = 'tobechecked' , checking_name = 'checking',\n                              default_value = NULL,\n                              PRINT = TRUE){\n\n  #' check whether list names (tobechecked) is within specified sets ('checking')\n  #' @export\n  #' @keywords internal\n  #' @param tobechecked   a named list / character vector to be checked\n  #' @param checking   a character vector, the names in `tobechecked` is supposed to show up here.\n  #' @param STOP  STOP if there are names in `tobechecked` not showing up in `checking`.\n  #' If FALSE, then we will delete the names not showing up in `checking`.\n  #' @param tobechecked_name  a character, name of 'tobechecked' for printing.\n  #' @param checking_name  a character, name of 'checking' for printing.\n  #' @param default_value  value to be returned if all names in tobechecked are not in 'checking'.\n  #' @param PRINT  whether print diagnostic information.\n  #' @return a 'purified' named list / character vector , with all names not showing up in `checking` deleted.\n\n  if ('character' %in% class(tobechecked)) names(tobechecked) = tobechecked\n\n  if (STOP) {\n    sanity_check(names(tobechecked), exact_in_match = checking)\n    }\n\n  # tobechecked = list('cut' = 1, 'dwewsdfds' = 2); checking = 'cut'\n  # tobechecked = list('cudasdst' = 1, 'dwewsdfds' = 2); checking = 'cut'\n\n  tobechecked_unmatched = names(tobechecked)[!names(tobechecked) %in% c(checking)]\n\n  if (PRINT && length(tobechecked_unmatched)){\n    cat('\\nfollowing names in ',tobechecked_name,' cannot be found ', checking_name, ', so delete them\\n',sep='')\n    print(tobechecked_unmatched)\n  }\n\n  tobechecked2 = tobechecked[names(tobechecked) %in% c(checking)]\n\n  if (length(tobechecked2) == 0) {\n    if (PRINT) cat('names in ', tobechecked_name,' cannot be matched with ',checking_name, ' NULL is returned.\\n', sep='')\n    tobechecked2 = default_value\n  }\n\n  return(tobechecked2)\n\n\n\n  if (FALSE && TRUE){\n    tobechecked = list('cut' = 1, 'dwewsdfds' = 2); checking = 'cut'\n\n    result =   check_names_delete(tobechecked, checking, STOP = FALSE,\n                                  tobechecked_name = 'focus_var',\n                                  checking_name = 'all_raw_vars')\n    result\n\n    result = check_names_delete(tobechecked, checking, STOP = FALSE)\n    result\n\n    tobechecked = c('cut', 'dsfsf'); checking = 'cut'\n    result = check_names_delete(tobechecked, checking, STOP = FALSE)\n    result\n  }\n\n}\n\n\n\nget_data_from_lm = function(model){\n\n  #' get raw data from lm or glm\n  #' @export\n  #' @keywords internal\n  #' @description get raw data from lm or glm\n  #' @param modle  a lm or glm.\n  #' @return a data.frame used as raw data for the model.\n\n  if (sum(c('lm','glm') %in% class(model)) == 0 ){\n    stop('model must be in the class lm or glm')\n  }\n\n  data1 = eval(model$call$data, environment(model$terms) ) # NOT works here\n\n  if (!'data.frame' %in% class(data1)){\n    data1 = model$data # NOT works here\n  }\n\n  return(data1)\n\n  if (FALSE && TRUE){\n\n    data_used = ggplot2::diamonds[0:10,]\n    model = lm(price~ cut + carat + I(carat^2) + I(carat^3) +\n                 I(carat  * depth) + cut:depth, data_used) # a GLM\n    get_data_from_lm(model)\n\n    data_used = 'data_used is deleted in this environment'\n    get_data_from_lm(model)\n  }\n}\n\nEnter_to_Continue = function(df_input_output = NULL){\n\n  #' Enter_to_Continue: wait your response to continue\n  #' @description wait your response to continue\n  #' @export\n  #' @param df_input_output  data.frame.\n  #' df_input_output shall be either NULL or a two column data.frame with characters as values, with first column as what you want to type, and second column as what you want to return.\n  #' If it is NULL, then it will return ' Press [enter] to continue; Type [s] to stop'.\n  #' See the sample code for the df case.\n  #'\n  #' @return Type through keyboard to continue in console.\n  #'\n\n  Return=NA\n\n  cat (\"\\n .... Press [enter] to continue; Type [s] to stop ....\")\n\n  if (!is.null(df_input_output) && !is.na(df_input_output) &&\n      nrow(df_input_output)>0){\n    for (pair_row in 1:nrow(df_input_output)) {\n      # pair = List[[1]]\n      cat(\"\\n .... Type [ \",paste(df_input_output[pair_row,1]),\" ]\",\" to return '\",\n          paste(df_input_output[pair_row,2]),\"' as object 'Return' ....\",sep='')\n    }\n  }\n\n  line <- readline()\n  if (line=='s' | line=='S') stop(\"Stop ! \")\n\n  # line = 'small'\n  if (!is.null(df_input_output) && !is.na(df_input_output) &&\n      nrow(df_input_output)>0 ) {\n\n    Match = match(line,paste(df_input_output[,1]))\n    Return = df_input_output[Match,2]\n  }\n\n  return(Return)\n\n  if (FALSE && TRUE){\n\n    Enter_to_Continue(rbind(c('small','small data'),c('n','normal'),c('w','weird curve')))\n\n  } # END TRUE\n\n}\n\n\nexpand_grid = function (List, KEEP.OUT.ATTRS = TRUE, stringsAsFactors = TRUE) {\n\n  #' a wrap up of \\code{expand.grid()} that takes list\n  #' @export\n  #' @keywords internal\n  #' @description  a wrap up of \\code{expand.grid()} that takes list\n  #' @param List  a list same as '...' in \\code{expand_grid()},\n  #' @param KEEP.OUT.ATTRS  stringsAsFactors, stringsAsFactors see \\code{expand_grid()}\n  #' @return Tsee \\code{expand_grid()}\n  #' @examples\n  #' expand_grid(list(A= c(1:3),b= letters[1:4]))\n  #' expand_grid(List = list(c(1:3)))\n\n\n  nargs <- length(args <- List)\n  if (!nargs)\n    return(as.data.frame(list()))\n  if (nargs == 1L && is.list(a1 <- args[[1L]]))\n    nargs <- length(args <- a1)\n  if (nargs == 0L)\n    return(as.data.frame(list()))\n  cargs <- vector(\"list\", nargs)\n  iArgs <- seq_len(nargs)\n  nmc <- paste0(\"Var\", iArgs)\n  nm <- names(args)\n  if (is.null(nm))\n    nm <- nmc\n  else if (any(ng0 <- nzchar(nm)))\n    nmc[ng0] <- nm[ng0]\n  names(cargs) <- nmc\n  rep.fac <- 1L\n  d <- sapply(args, length)\n  if (KEEP.OUT.ATTRS) {\n    dn <- vector(\"list\", nargs)\n    names(dn) <- nmc\n  }\n  orep <- prod(d)\n  if (orep == 0L) {\n    for (i in iArgs) cargs[[i]] <- args[[i]][FALSE]\n  }\n  else {\n    for (i in iArgs) {\n      x <- args[[i]]\n      if (KEEP.OUT.ATTRS)\n        dn[[i]] <- paste0(nmc[i], \"=\", if (is.numeric(x))\n          format(x)\n          else x)\n      nx <- length(x)\n      orep <- orep/nx\n      x <- x[rep.int(rep.int(seq_len(nx), rep.int(rep.fac,\n                                                  nx)), orep)]\n      if (stringsAsFactors && !is.factor(x) && is.character(x))\n        x <- factor(x, levels = unique(x))\n      cargs[[i]] <- x\n      rep.fac <- rep.fac * nx\n    }\n  }\n  if (KEEP.OUT.ATTRS)\n    attr(cargs, \"out.attrs\") <- list(dim = d, dimnames = dn)\n  rn <- .set_row_names(as.integer(prod(d)))\n  structure(cargs, class = \"data.frame\", row.names = rn)\n\n  # expand_grid(list(A= c(1:3),b= letters[1:4]))\n  # expand_grid(List = list(c(1:3)))\n\n}\n\n\nMode <- function(x) {\n\n  #' get mode number from a numeric vector\n  #' @export\n  #' @keywords internal\n  #' @param x a numeric vector\n  #' @return a numeric value mode number of x\n  #' @examples\n  #' Mode(c(1,1,1,10,10))\n\n  ux <- unique(x)\n  ux[which.max(tabulate(match(x, ux)))]\n}\n\n\nis_increase = function(x){\n\n  #' check whether the vector is increasing\n  #' @export\n  #' @keywords internal\n  #' @param x a numeric vector\n  #' @return \\code{TRUE} if increasing, \\code{FALSE} if not\n  #' @examples\n  #' is_increase(c(1,1,1,10,10))\n  #' is_increase(c(1,2,1,10,10))\n\n  all(x == cummax(x))\n}\n\n\nis_decrease = function(x){\n\n  #' check whether the vector is decreasing\n  #' @export\n  #' @keywords internal\n  #' @param x a numeric vector\n  #' @return \\code{TRUE} if decreasing, \\code{FALSE} if npt.\n  #' @examples\n  #' is_decrease(rev(c(1,1,1,10,10)))\n  #' is_decrease(c(1,2,1,10,10))\n\n  all(x == cummin(x))\n}\n\n\ncheck_vec_meaningful = function (x){\n\n  # an attach_Load_First.R function\n\n  #' check x is a meaningful vector\n  #' @export\n  #' @keywords internal\n  #' @param x any object\n  #' @return If it is a meaningful vector, the return \\code{TRUE}, otherwise \\code{FALSE}\n  #' @details we define \"a meaningful vector\" as\n  #' 1. cannot be a 'list'\n  #' 2. with positive length,\n  #' 3. with valid common one-dimensional slicing method, like x[1] etc, # so factor, character, numeric will pass the check\n  #' 4. not all elements being NA.\n\n  if ('factor' %in% class(x)) x = as.character(x) #is.vector will think factor as FALSE\n\n  if (is.null(x) || length(x)==0) { # is.null will check the object as a whole, not each single element\n    y = 0\n  } else if (!is.vector(x) || 'list' %in% class(x)) { # is.vector will return true for list and vector!\n    stop('x is not a vector, it might be a list or data.frame or matrix ....')\n  } else if (sum(is.na(x) + is.nan(x)  )==length(x) ){ # this method will allow logic(0) and integer(0)\n    y = 0\n  } else {\n    y = 1\n  }\n\n  return(y)\n\n  if (FALSE && TRUE){\n\n    check_vec_meaningful(c(NA,NA)) # NOT PASS\n\n    tryCatch(check_vec_meaningful(x=list(NA,NaN)),\n             error = function(err){\n               print(err)\n               }\n             )# NOT PASS\n\n    check_vec_meaningful(c(NA,1)) # PASS\n    check_vec_meaningful(c(NULL,1)) # PASS\n    check_vec_meaningful(factor(c(NA,1,1))) # PASS\n    check_vec_meaningful(1) # PASS\n    check_vec_meaningful('1') # PASS\n\n  }\n}\n\n\n\n\nsanity_check = function(x ,\n                        NULL_allowed = FALSE, # whether is.NULL is allowed\n                        Class = NULL, # Class is the correct class that class(x) should contains\n                        min_oberserv = NULL, # min_oberserv is the min number of row / length that x should have\n                        exact_in_match = NULL, # each element of x shall be found in the exact_in_match vector\n                        # if exact_in_match is a data.frame, we will get the colnames of it as exact_in_match\n                        fuzzy_match = NULL,\n                        exact_length = NULL, # exact_length can let you test the exact length of a vector, OR exact number of colnames\n                        complete_cases = NULL, # TRUE or NULL # check whether a dataframe have NA values\n                        STOP = 1, # STOP: whether to stop if there is an error.\n                        message_provided = ''\n){\n  # from attach_load_first.R\n\n  # Goal: check whether the inout is in the right class, or right length , or right values....\n  # x is the object you want to check\n\n\n  #' check x with various characters\n  #' @export\n  #' @keywords internal\n  #' @param x an object to be checked.,\n  #' @param NULL_allowed whether a x == NULL is allowed,\n  #' @param Class  the correct class of x\n  #' @param min_oberserv the min number of row / length that x should have,\n  #' @param exact_in_match\n  #' each element of x shall be found in the exact_in_match vector\n  #' if exact_in_match is a data.frame, we will get the colnames of it as exact_in_match\n  #' @param fuzzy_match TEST feature\n  #' @param exact_length  can let you test the exact length of a vector, OR exact number of colnames\n  #' @param complete_cases TRUE or NULL # check whether a dataframe have NA values\n  #' @param STOP whether to stop if there is an error.\n  #' @param message_provided replace the default error message\n  #'\n  #' @return return nothing if x passes checks, otherwise an error message\n  #'\n  #' @description a single function that can do several different types of sanity checks at the same time\n  #' @details See sample code\n\n\n  Show_Name = deparse(substitute(x)) # to let the code print the original name of x\n\n  Message = NULL\n\n  if ('factor' %in% class(x)) x = as.character(x)\n\n  ## --------------  check null\n  if (NULL_allowed == FALSE && is.null(x)) stop(Show_Name, ' is NULL, which is not allowed')\n\n  ## --------------  check class\n\n  if (check_vec_meaningful(Class)){\n\n    if (class(Class)!='character') stop('Class must be an character')\n\n    Input_Class=class(x)\n    #  if integer and numeric class, we treat them as same\n    if (sum(c('integer','numeric','logical') %in% Class)) {\n      # Class = 'test'\n      Class=c(Class,c('numeric','integer','logical'))\n    }\n\n    # check class\n\n    if (sum(Class %in% Input_Class)==0){\n      cat(\"\\n \\n------------------- \\n\")\n\n      Message =\n        paste(\"\\n\",Show_Name,\" is in \",class(x), \"\\n\",\"It shall be in class \",paste(Class,collapse = ' or '),\"\\n\")\n    }\n  }\n\n  ## --------------  check exact values:\n  if ('factor' %in% class(exact_in_match)) exact_in_match = as.character(exact_in_match)\n\n  if (\"data.frame\" %in% class(exact_in_match)) exact_in_match = colnames(exact_in_match)\n\n\n  if (check_vec_meaningful(exact_in_match) ){\n\n    if ( !is.vector(x) & !sum(c('data.frame',\"matrix\") %in% class(x) )) {\n      stop(\"x must be a vector or matrix or data.frame when you want to check its match\")\n    }\n\n\n    if (is.vector(x) && sum(x %in% exact_in_match)!=length(x)  ){\n      # if x is the vector, then try to match the value\n      cat(\"\\n \\n------------------- \\n\")\n      print(exact_in_match)\n      Message = paste(\"\\n\",Show_Name,\" shall have values above \\n \\n\")\n    }\n    if (\n      # if x is a data.frame, then try to match the colnames\n      sum(c('data.frame',\"matrix\") %in% class(x) ) && sum(colnames(x) %in% exact_in_match)!=ncol(x)\n    ){\n\n      cat(\"\\n \\n------------------- \\n\")\n      print(exact_in_match)\n      Message = paste(\"\\n\",Show_Name,\" shall have colnames above \\n \\n\")\n    }\n  }\n\n  ## -------------- check fuzzy values\n\n  # each element of x shall be fuzzy matched in the fuzzy_match vector\n\n  if (\"data.frame\" %in% class(fuzzy_match)) fuzzy_match = colnames(fuzzy_match)\n  if (check_vec_meaningful(fuzzy_match) ){\n\n    if ( !is.vector(x) & !sum(c('data.frame',\"matrix\") %in% class(x) )) {\n      stop(\"x must be a vector or matrix or data.frame when you want to check its match\")\n    }\n\n    # if x is the vector, then try to match the value\n    if (is.vector(x)) x_match = x\n    if (sum(c('data.frame',\"matrix\") %in% class(x))) x_match = colnames(x)\n\n    for (M in x_match) {\n\n      if (sum(str_detect(M,fuzzy_match))==0){\n\n        cat(\"\\n \\n------------------- \\n\")\n        print(fuzzy_match)\n        Message = paste(\"\\n\",Show_Name,\" shall have values / colnames above \\n \\n\")\n        print(Message)\n      }\n    }\n  }\n\n  ## -------------- check lengths\n  if (  check_vec_meaningful(exact_length) ) {\n\n    if (!check_single_numeric(exact_length)) {\n      stop ('exact_length must be numeric and has single value larger than 1')\n    }\n\n    if ( !is.vector(x) & !sum(c('data.frame',\"matrix\") %in% class(x) )) {\n      stop(\"x must be a vector or matrix or data.frame when you want to check its length or number of cols\")\n    }\n\n    if (\n      (is.vector(x) && length(x)!=exact_length) |\n      (sum(c('data.frame',\"matrix\") %in% class(x) ) && ncol(x)!=exact_length)\n    ){\n      cat(\"\\n \\n------------------- \\n\")\n      Message = paste(\"\\n\",Show_Name,\" shall have the length / number of columns as \", exact_length,\"\\n\")\n    }\n  }\n\n  # -------------  check min_oberserv, if you defined min_oberserv\n  if (check_vec_meaningful(min_oberserv)){\n\n    if (!check_single_numeric(min_oberserv)){\n      stop (\"min_oberserv shall have a single numeric positive values\" )\n    }\n\n    if (\n      (class(x) %in% c(\"data.frame\",\"matrix\") && nrow(x)<min_oberserv) ||\n      (is.null(nrow(x)) && length(x)<min_oberserv)\n    ){\n      cat(\"\\n \\n------------------- \\n\")\n\n      Message =\n        paste(\n          \"\\n\",\n          Show_Name, \" shall have more observations than \", min_oberserv,\n          \"\\n\"\n        )\n    }\n  }\n\n  ## ---------- check min_oberserv\n  if ((check_vec_meaningful(complete_cases)) && complete_cases &&\n      !is.null(nrow(x)) &&\n      !sum( complete.cases(x) )==nrow(x) ){\n    Message =\n      paste(\"\\n \\n------------------- \\n\")\n\n    Rows_NA=which(complete.cases(x)==0)\n    cat(Rows_NA)\n\n    Message =\n      paste(\"\\n\",\"Rows above has NA\",\"\\n\")\n  }\n\n  if (length(Message)){\n    cat(message_provided)\n\n    if (STOP == 1) {\n      stop(Message)\n    } else {\n      warning(Message)\n    }\n  }\n\n  if (FALSE && TRUE){\n\n    ###_____ unit test ____\n\n\n    data = ggplot2::diamonds\n    # sanity_check(dasfdfdsfsgre)\n    null_checl = NULL ;\n    tryCatch( sanity_check(null_checl),\n              error = function(err) print(err))\n    tryCatch( sanity_check(null_checl,NULL_allowed = TRUE),\n              error = function(err) print(err))\n\n\n    tryCatch( sanity_check(c('x','y'),min_oberserv = 3),\n              error = function(err) print(err))\n    tryCatch( sanity_check(c('x','y'),min_oberserv = 2),\n              error = function(err) print(err))\n\n    tryCatch( sanity_check(data,Class = 'data.frame2'),\n              error = function(err) print(err))\n    tryCatch( sanity_check(data,min_oberserv = 3000000),\n              error = function(err) print(err))\n\n    tryCatch( sanity_check(data,exact_length = ncol(data) ),\n              error = function(err) print(err))\n    tryCatch( sanity_check(\n      data.frame(data,NA,stringsAsFactors = FALSE)[1:10,],\n                           complete_cases = TRUE ),\n              error = function(err) print(err))\n\n\n    colnames(data)\n    tryCatch( sanity_check(x= c('carat') ,exact_in_match = data),\n              error = function(err) print(err))\n    tryCatch( sanity_check(x= c('carat') ,exact_in_match = colnames(data)) ,\n              error = function(err) print(err))\n    tryCatch( sanity_check(x= c('carat2') ,exact_in_match = data),\n              error = function(err) print(err))\n    tryCatch(  sanity_check(x= c('carat','carat2') ,exact_in_match = data),\n               error = function(err) print(err))\n\n    tryCatch(  sanity_check(x=colnames(data),exact_in_match = c('carat')),\n               error = function(err) print(err))\n\n    tryCatch(   sanity_check(x=data,exact_in_match = c('carat2')),\n                error = function(err) print(err))\n\n\n\n\n\n\n\n  }\n\n}\n\n\ncheck_single_numeric = function(x, sign = 1){\n\n  # an attach_Load_First.R function\n  #' check whether an object is a single numeric number\n  #' @export\n  #' @keywords internal\n  #' @param x  the object to be checked\n  #' @param sign the correct sign: 1 or -1\n  #' @return a boolean, whehter x is a valid numeric.\n\n  if (sum(c('numeric','integer','logical') %in% class(x)) && length(x)==1 && x*sign>0) {\n    x= 1\n  } else {x = 0}\n\n  return(x)\n\n  if (FALSE && TRUE){\n    check_single_numeric(x = nrow(ggplot2::diamonds))\n  }\n}\n\n\n\n### Unfished =====================\n\n\n\n### From Others --------------------\n\n\n\nstripGlmLR = function(model) {\n\n  # from attach_load_first.R\n\n  # Trimming the Fat from glm() Models in R: reduce the size of it\n  # http://www.r-bloggers.com/trimming-the-fat-from-glm-models-in-r/\n\n  #' make the lm or glm thin\n  #' @keywords internal\n  #' @param model glm or lm.\n  #' @return a thinner model\n  #' @author  Nina Zumel\n\n  model$y = c()\n  model$model = c()\n\n  model$residuals = c()\n  model$fitted.values = c()\n  model$effects = c()\n  model$qr$qr = c()\n  model$linear.predictors = c()\n  model$weights = c()\n  model$prior.weights = c()\n  model$data = c()\n\n  model$family$variance = c()\n  model$family$dev.resids = c()\n  model$family$aic = c()\n  model$family$validmu = c()\n  model$family$simulate = c()\n  attr(model$terms,\".Environment\") = c()\n  attr(model$formula,\".Environment\") = c()\n\n  model$striped = TRUE\n\n\n\n  return(model)\n\n\n  if( FALSE && FALSE) {\n\n\n    model = lm(price~  I(carat^   2) + cut  - carat:table - cut ,ggplot2::diamonds)\n\n    model = stripGlmLR(model)\n\n    model$residuals\n\n    for (i in attributes(model)$names){\n      print(model[[i]])\n    }\n  }\n\n}\n\n\n\n\n###  Formula Functions  -------------------\n\n# NOT supposed to show to public\n\n\n\nget_x_hidden = function(model,\n                        method = c(\"raw\",\"model\",\"coeff\"),\n                        data = NULL){\n  # from attach_load_first.R\n\n  #' the underlying function of \\code{\\link{get_x}}\n  #'\n  #' @export\n  #' @keywords internal\n  #'\n  #' @details\n  #' This is the one of many underlying functions that powers \\code{\\link{get_x}}.\n  #' The major difference is: \\code{\\link{get_x}} can deal with dirty formula,\n  #' but \\code{get_x_hidden} cannot. 'dirty formula' means a formula with redundant terms,\n  #' such as \\code{y ~ x1 + x2 -x1}.\n  #'\n  #' @param model method,data  \\code{\\link{get_x}}\n  #' @seealso \\code{\\link{get_x}}\n  #' @return  \\code{\\link{get_x}}\n\n\n  # NOT supposed to show to public\n\n  # if method = \"raw\": only get the raw var: you will get \"x\" instead of \"log(x)\" from formula y~log(x).\n  # if method = \"model\": only get the raw var: you will get \"x\" instead of \"log(x)\" from formula y~log(x).\n  # if method = \"coeff\": used for categorical variables, you will get\n  # \"cut.L\"       \"cut.Q\"       \"cut.C\"       \"cut^4\"\n\n  # instead of just cut\n  # from lm(price ~ cut,data = ggplot2::diamonds)\n\n  method = match.arg(method)\n\n  #    if (is.null(data)) data=data.frame(DELETE_LATER.....123.= 0)\n  #       # some formulas contain \".\" to represent all other vars in data.\n  #       # if data is null, then \".\" has no meaning at all\n  #       # so we want to delete it\n  #       # just replace \".\" by \"DELETE_LATER.....123.\" temporarily, later we will delete it.\n  #       # so this \"DELETE_LATER.....123.\" is just a temp placeholder\n\n\n  sanity_check(model, Class = c(\"lm\",\"glm\",'formula','character') ,\n               message_provided = 'model must be a lm, glm, formula or string or formula'    )\n\n  if (method == \"raw\") {\n    # all.vars() cannot deal with dirty formula\n    # it has to depend on coeff or model vars to get cleaned raw vars\n    var = all.vars(formula (model))\n\n    # var = all.vars(formula (model))\n    # var = all.vars(formula (model.frame(model)))\n    # var = all.vars(formula (model.matrix(model))) # invalid\n\n    var = var[-1]\n  }\n\n  if (method == \"model\") {\n    # this method is able to deal with dirty formulas\n    var = terms(formula(model)) %>% attr(.,\"factors\") %>% colnames()\n\n    #     if (sum(c(\"lm\",\"glm\") %in% class(model)) ) {\n    #\n    #       var = model$terms %>% attr(.,\"factors\") %>% colnames()\n    #\n    #     }\n    #     if (sum(c(\"formula\",\"character\") %in% class(model)) ) {\n    #       if (is.null(data)) {\n    #         stop(\"data must be provided when 'model' argument is just a formula and\n    #              you want to get 'model' vars\")\n    #       }\n    #       var = colnames(model.frame(formula(model),data))[-1]\n    #       }\n\n  }\n\n  if (method == \"coeff\") {\n    # works in dirty formulas\n\n    if (sum(c(\"lm\",\"glm\") %in% class(model))\n    )  {\n      var = names(model$coeff)\n    }\n    if (sum(c(\"formula\",\"character\") %in% class(model))) {\n\n      if (is.null(data)) {\n        stop(\"data must be provided when 'model' argument is just a formula and\n             you want to get 'coeff' vars\")\n      }\n      data = data.frame(data)\n\n      var = colnames(model.matrix(formula(model),data))\n      }\n    var = var[\"(Intercept)\" !=var]\n  }\n\n  var = gsub(\" \",\"\",var)\n\n\n\n  return(var[var != \"DELETE_LATER.....123.\"])\n\n\n\n  if ( FALSE && TRUE) {\n\n    #\n    data = ggplot2::diamonds\n    diamond_lm  =  lm(price~  I(carat^   2) + cut  + carat*table ,ggplot2::diamonds)\n\n    #_________ input as model\n    get_x_hidden(model = diamond_lm,method = 'raw')\n    get_x_hidden(diamond_lm,method = 'model')\n    get_x_hidden(diamond_lm,method = 'coeff')\n\n    #_______ input as formula\n    get_x_hidden(formula(diamond_lm),method = 'model')\n    # data is required when input is formula\n    get_x_hidden(formula(diamond_lm), data = ggplot2::diamonds, method = 'coeff')\n\n    tryCatch(\n      get_x_hidden(formula(diamond_lm),method = 'coeff'),\n      error =function(err){\n        print(err)\n      }\n    )\n\n\n\n\n\n    #________ irregular formulas __________\n\n    model_dirty = model = lm(price~  I(carat^   2) + cut  -\n                               carat:table - cut ,ggplot2::diamonds)\n\n    # WRONG for raw vars\n    get_x_hidden(model_dirty)\n\n    # correct for model vars\n    get_x_hidden(price~  I(carat^2) + cut  -\n                   carat:table - cut,\n                 data = ggplot2::diamonds, method ='model')\n\n    get_x_hidden(model_dirty,method = 'model')\n    get_x_hidden(model_dirty,data = ggplot2::diamonds, method = 'model')\n    get_x_hidden(model_dirty, method = 'model')\n\n    #___________ coeff vars __________\n\n    # clean\n    get_x_hidden(model_dirty, data = ggplot2::diamonds, method = 'coeff')\n    get_x_hidden(formula(model_dirty),data = ggplot2::diamonds, method = 'coeff')\n\n\n    #\n    # # dirty\n    # attr(terms((price~  I(carat^2) + cut  + carat:table - cut)),\"factors\") %>% colnames()\n    #\n    # #______________ test: how to get variables\n    # model.matrix(formula(model_dirty),data = ggplot2::diamonds) %>% colnames\n    # terms(formula(diamond_lm)) %>% attr(.,\"factors\") %>% colnames()\n    # terms(formula(model_dirty)) %>% attr(.,\"factors\") %>% colnames()\n    # terms(formula(model_dirty)) %>% attr(.,\"factors\") %>% rownames()\n    #\n    #\n    # # clean method for model vars\n    # terms((price~  I(carat^2) + cut  - carat:table - cut)) %>% attr(.,\"factors\") %>% colnames()\n    # model_dirty %>% terms %>% attr(.,\"factors\") %>% colnames()\n    # formula(model_dirty) %>% terms %>% attr(.,\"factors\") %>% colnames()\n\n\n\n\n  }\n}\n\n\n\npaste_formula = function(Formula, # a formula, or a model (like glm/lm) so that formula(model) can give a formula\n                         exclude_y = FALSE, # whether to exclude y in the pasted formula\n                         clean = FALSE\n){\n  # from attach_load_first.R\n  # paste a formula into text in the same line.\n  # note that all spaces will be deleted\n\n  #' paste a formula as string\n  #'\n  #' @details\n  #' a pasted formula in string, with all spaces deleted.\n  #' This function uses \\code{\\link{get_y}} and \\code{\\link{get_x}} behind the scene.\n  #'\n  #' @param Formula  a formula to be pasted.\n  #' @param exclude_y  a boolean, whether to exclude y when paste. Default is FALSE.\n  #' @param clean  a boolean, whether to clean dirty formula: for example -- price ~ cut + carat - cut\n  #' will be cleaned into price ~ carat. Default is FALSE.\n\n  #' @export\n  #' @return  a pasted formula in string, with all spaces deleted.\n\n  y = get_y(Formula,\"model\")\n  ## max_length of formula = 500, a numeric, max length of the formula in one line.\n  ##  If the formula is longer than this number, then the pasted formula will be showed in multiple lines.\n\n  if (clean){\n    # Formula = y ~ x - x\n    Formula_x_part = paste(get_x(Formula,'model'),collapse = '+',sep='')\n    if (str_length(Formula_x_part)==0) Formula_x_part = 1\n    Formula = paste(y ,'~',Formula_x_part, sep='')\n  } else {\n    Formula = gsub(\" \",\"\",deparse(formula(Formula),500))\n  }\n\n  if (exclude_y) {\n    Formula = gsub(paste(y,\"~\",sep=''),\"\",Formula,fixed = TRUE)\n  }\n  return(Formula)\n\n\n  if( FALSE && TRUE){\n\n    paste_formula(price~carat +cut)\n    paste_formula(price~carat + cut)\n\n    paste_formula(price~carat +cut,exclude_y = TRUE)\n    paste_formula(Formula = price ~ cut + carat, clean = TRUE)\n\n    paste_formula(price~carat +cut - cut, clean = TRUE)\n\n    # irregular formulas: cross lines\n    paste_formula(price~carat +\n                    cut ~ dsad)\n\n    paste_formula(price~carat +\n                    cut ~ dsad,exclude_y = TRUE)\n\n  }\n}\n\n\n\n\nget_y = function(Formula,method = c(\"raw\",\"model\",\"coeff\")){\n  # from attach_load_first.R\n\n  # depend on get_x_hidden in the 'raw' case, so no need for the data in the 'raw' case.\n  # in \"model\" and \"coeff\" case, we use regular expression to get y, so no need for data either\n\n  #' get y (right hand of var)\n  #' @export\n  #' @details\n  #' What do 'raw' variable, 'model' variable, and 'coeff' variable mean?\n  #'\n  #'\\itemize{\n  #'\\item raw var is the underlying variable without any calculation or transformation.\n  #'\\item model var is the underlying variable with calculations or transformation.\n  #'\\item coeff var is the coefficient variable in the model output. So only evaluated model has coeff var.\n  #' }\n  #'\n  #' In the formula, \\code{log(y) ~ x1 + x2}, we have:\n  #' 'raw' variable for \\code{y}: \\code{y}\n  #' 'model' variable for \\code{y}: \\code{log(y)}\n  #' 'coeff' variable for \\code{y}: \\code{log(y)}\n  #'\n  #' More examples see the sample code below.\n\n  #' @param Formula  a formula to be paste.\n  #' @param method  either \\code{'raw','model'}, or \\code{'coeff'}, to decide what kind variables to show.\n  #' Default is 'raw'. See section Detials below.\n  #' @return y in formula\n\n\n\n  method = match.arg(method)\n\n  sanity_check(Formula, Class = c(\"lm\",\"glm\",'formula','character') ,\n               message_provided = 'model must be a lm, glm, formula or string or formula'    )\n\n  if (method == \"raw\") {\n\n    var = all.vars(formula (Formula))[1]\n  } else {\n    Formula = gsub(\" \",\"\",deparse(formula(Formula),500))\n    var = gsub(\"\\\\~.*\",\"\",Formula,perl = TRUE)\n  }\n\n  return(var)\n\n  if ( FALSE && TRUE) {\n    get_y(log(price) ~sdfsf + dsa )\n    get_y(log(price) ~ sdfsf + dsa, method = \"model\")\n    get_y(log(price) ~ sdfsf + dsa, method = \"coeff\") # same as model var in the get_y() case\n\n    # can deal with un-regular formula\n    get_y(log(price) ~sdfsf + dsa ~ dsad)\n    get_y(log(price) ~ sdfsf + dsa ~ dsad, method = \"coeff\")\n    get_y(log(price) ~ sdfsf + dsa ~ dsad, method = \"model\")\n\n    model_dirty = model = lm(price~  I(carat^   2) + cut  - carat:table - cut ,ggplot2::diamonds)\n    get_y(model_dirty)\n\n  }\n}\n\n\n\n\nget_contrast = function(model,\n                        data = NULL,\n                        PRINT = TRUE,\n                        return_method = FALSE,\n                        # if FALSE, then return the names of contrasted vars,\n                        # if TRUE, then return the name of contrast function used.\n                        delete.minus.var = TRUE\n                        # whether to delete x2 in  y ~ x1 - x2, default is yes.\n){\n\n  # from attach_load_first.R\n  # independent from get_x_hidden\n\n  #' get contrast of categorical variables in a model\n  #'\n  #' @export\n  #' @details\n  #' When R put categorical vars in the linear model, R will transform them into set of 'contrast' using\n  #' certain contrast encoding schedule. See example code and the reference link below for details.\n  #'\n  #' @param model  a model, either \\code{lm} or \\code{glm}.\n  #' @param data   dataframe, to provide new data to evaluate the model. If NULL (default), then we use the default data in the model.\n  #' @param PRINT  a boolean, whether to print messages. Default is TRUE.\n  #' @param return_method  a boolean, whether to return the method of contrast, rather than the contrast itself. Default is FALSE.\n  #' @param delete.minus.var  a boolean. whether to delete x2 in  y ~ x1 - x2. Default is TRUE.\n  #' @return contrasts of the categorical vars in the model, or the contrast method if \\code{return_method} is TRUE.\n  #' @references \\url{http://www.ats.ucla.edu/stat/r/library/contrast_coding.htm}\n\n  # input is a model or a model.matrix\n  # if there is categorical var, output is a list,\n  # where names of the list are the names of raw categorical vars\n  # where values of the list are the names of contrasted coeffs of the corresponding categorical vars\n  # if no categorical var, then return NULL\n\n  #   if ( sum(c('lm','glm') %in% class(model))\n  #        ){\n  #     mm = model.matrix(model)\n  #   } else if ('matrix' %in% model){\n  #     mm = model\n  #   } else {\n  #     stop('class of input shall be model.matrix or a model')\n  #     }\n\n\n  Contrast = model$contrasts # a list, names as model var\n  if (delete.minus.var) Contrast = Contrast[names(Contrast) %in% get_x(model,'model')]\n\n  if (length(Contrast)==0){\n    if (PRINT) message('no contrasts are found')\n    result = NULL\n  } else {\n    if (is.null(data)) {\n      data = model.frame(model)\n      if (is.null(data))  stop(\"data must be provided, or the 'model' argument must be lm/glm\")\n    } else {\n      data = data.frame(data)\n\n      data = model.frame(formula = model, data = data)\n\n\n    }\n\n    result = list()\n\n\n    for (i in names(Contrast)){\n      # i = names(Contrast)[1]\n      if (is.null(data[,i])) {\n        if (is.null(data)) stop(i, ' can not be found in the data')\n      }\n\n      if ( return_method) {\n        result[[i]] = as.name( Contrast[[i]] )\n      } else {\n        result[[i]] =\n\n          list(\n            as.name( Contrast[[i]] ), # this is contrast method\n            unique(data[,i])\n          ) %>% as.call %>% eval %>% colnames %>% paste(i,.,sep='')\n      }\n    }\n  }\n\n  return(result)\n\n  if (FALSE && TRUE){\n    get_contrast(lm(price ~ carat + I(carat^2) + cut:carat +\n                      color,ggplot2::diamonds))\n    get_contrast(lm(price ~ carat + I(carat^2) + cut:carat +\n                      color,ggplot2::diamonds),return_method = TRUE)\n\n    # dirty formulas: all categorical vars are with minus sign\n    # no categorical vars, thus no contast\n    get_contrast(lm(price ~ carat + I(carat^2) ,ggplot2::diamonds))\n\n    model_dirty = lm(price ~ carat + I(carat^2) - cut:carat - color,\n                     ggplot2::diamonds)\n    get_contrast(model = model_dirty )\n\n    diamond_lm3 = lm(price~ I(cut) + depth,ggplot2::diamonds) # a GLM\n    get_contrast(model = diamond_lm3 )\n\n\n  }\n\n}\n\n\n\n\nget_model_pair = function(model,data = NULL,pair_with = c('coeff','raw')){\n\n  # from attach_load_first.R\n\n  # this function will create links between raw, model and coeffs.\n\n  # output is a list\n  # list names are model vars\n  # value of list names are the coeffs or raws\n\n  # will be used in get_x, to link to raw vars to model vars\n  # pair_with = 'coeff'\n\n  #' get a list of model vars with their corresponding coeff vars or raw vars.\n  #' @export\n  #' @details get a list of model vars with their corresponding coeff vars or raw vars.\n  #' See \\code{\\link{get_x}} for the meaning of model var, coeff var and raw var.\n  #'\n  #' @param model  a lm or glm output\n  #' @param data  NULL (default) or data.frame, a new dataset to evaluate the categorical variables.\n  #' If NULL, then use the data used in model itself.\n  #' @param pair_with  either 'raw' (default) or 'coeff', to decide the elements of list are raw vars or coeff vars.\n  #' See \\code{\\link{get_x}} for the meaning of model var, coeff var and raw var.\n  #' @return a list with names as model vars and elements as their corresponding coeff/raw vars\n\n\n  # pair_with = 'coeff'\n  pair_with = match.arg(pair_with)\n  y = get_y(model,'model')\n  result = list()\n  model_var = get_x_hidden(model,data = data, 'model')\n\n  for (i in model_var){\n    # i = model_var[1]\n    if ( pair_with == 'raw') {\n      result[[i]] = get_x_hidden (paste( y,'~', i),data = data, method  = pair_with)\n    }\n    if ( pair_with == 'coeff'){\n      if (is.null(data)) {\n        data = get_data_from_lm(model)\n        if (is.null(data)) stop ('data is not provided and cannot be found in the model')\n      }\n      data = data.frame(data)\n\n      result[[i]] = get_x_hidden (paste( y,'~', i),data = data, method  = pair_with)\n    }\n\n  }\n\n  return(result)\n\n  if(FALSE && TRUE){\n    # return coeff\n    get_model_pair(model = price~  I(carat^2) + cut  + carat*table, data = ggplot2::diamonds)\n    # return raw vars\n    get_model_pair(price~  I(carat^2) + cut  + carat*table, data= ggplot2::diamonds, pair_with = 'raw')\n\n    # correctly deal with irregular formulas\n    model_dirty = lm(price~  I(carat^   2) + cut  - carat:table - cut ,ggplot2::diamonds)\n    get_model_pair(model_dirty,pair_with = 'raw')\n  }\n}\n\n\n\nget_x = function(model ,\n                 method = c(\"raw\",\"model\",\"coeff\"),\n                 data = NULL){\n\n  # a function that shall be exported\n\n  #' get x (left hand of var) from model or formula\n  #' @export\n  #' @details\n  #' What do 'raw' variable, 'model' variable, and 'coeff' variable mean?\n  #'\n  #'\\itemize{\n  #'\\item raw var is the underlying variable without any calculation or transformation.\n  #'\\item model var is the underlying variable with calculations or transformation.\n  #'\\item coeff var is the coefficient variable in the model output.\n  #'      So only evaluated model has coeff vars.\n  #'      Most of the time one categorical variable will have several coeff vars according to their contrast encoding. see \\code{\\link{get_contrast}}\n  #' }\n  #'\n  #' Example:\n  #'\n  #' In the model, \\code{log(price) ~ cut + I(carat^2)} in \\code{diamonds} data, we have:\n  #' \\itemize{\n  #' \\item 'raw' variables of x: \\code{carat} and \\code{cut}.\n  #' \\item 'model' variables of x: \\code{I(carat^2)} and \\code{cut}.\n  #' \\item 'coeff' variables of x: \\code{cut.L,\"cut.Q\",\"cut.C\",\"cut^4\"} and \\code{I(carat^2)}.\n  #' }\n  #'\n  #' See the sample code below for more examples.\n\n  #' @param model  a formula or a model.\n  #' @param method  either \\code{'raw','model'}, or \\code{'coeff'}, to decide what kind variables to show.\n  #' Default is 'raw'. See section Detials below.\n  #' @param data  a dataframe, to provide new data to evaluate the model. If NULL (default), then we use the default data in the model.\n  #' @return x variables in the formula or model\n  #' @import utils\n  #' @import ggplot2\n  #' @import plyr\n  #' @import pryr\n  #' @import stringr\n  #' @import stats\n  #' @import magrittr\n  #' @import scales\n\n\n  method = match.arg(method)\n\n  if (method == 'raw'){\n    var =  get_model_pair(model = model,data = data, pair_with = 'raw') %>% unique\n    names(var) = NULL\n    var = var %>% unlist %>% unique\n  } else {\n    var = get_x_hidden(model = model,\n                       method = method,\n                       data = data)\n  }\n\n  return(var)\n\n  if(FALSE && TRUE){\n    # use the sample code from get_x_hidden\n    #\n    data = ggplot2::diamonds\n    diamond_lm  =  lm(price~  I(carat^   2) + cut  + carat*table ,ggplot2::diamonds)\n\n    #_________ input as model\n    get_x(model = diamond_lm,method = 'raw')\n    get_x(diamond_lm,method = 'model')\n    get_x(diamond_lm,method = 'coeff')\n\n    #_______ input as formula\n    get_x(formula(diamond_lm),method = 'model')\n    # data is required when input is formula\n    get_x(formula(diamond_lm), data = ggplot2::diamonds, method = 'coeff')\n\n    tryCatch(\n      get_x(formula(diamond_lm),method = 'coeff'),\n      error =function(err){\n        print(err)\n      }\n    )\n\n\n\n    #________ irregular formulas __________\n\n    model_dirty = model = lm(price~  I(carat^   2) + cut  - carat:table - cut ,ggplot2::diamonds)\n\n    # CORRECT for raw vars\n    get_x(model_dirty)\n\n    # correct for model vars\n    get_x(price~  I(carat^2) + cut  - carat:table - cut,data = ggplot2::diamonds, method ='model')\n    get_x(model_dirty,method = 'model')\n    get_x(model_dirty,data = ggplot2::diamonds, method = 'model')\n    get_x(model_dirty, method = 'model')\n\n    # clean method for model vars\n    # terms((price~  I(carat^2) + cut  - carat:table - cut)) %>% attr(.,\"factors\") %>% colnames()\n    # model_dirty %>% terms %>% attr(.,\"factors\") %>% colnames()\n    # formula(model_dirty) %>% terms %>% attr(.,\"factors\") %>% colnames()\n\n  }\n}\n\n\n\nget_model_with_coeff = function(model,data = NULL){\n  # depend on get_model_pair\n\n\n  #' get a list of model variables with their corresponding coeff vars.\n  #'\n  #' @export\n  #' @description a wrap up function of \\code{\\link{get_model_pair}}\n  #' @details See \\code{\\link{get_model_pair}}\n  #'\n  #' @param model See \\code{\\link{get_model_pair}}\n  #' @param data See \\code{\\link{get_model_pair}}\n  #' @return a list with names as model vars and elements as their corresponding coeff\n\n\n  return(get_model_pair(model = model, data=data, pair_with = 'coeff'))\n\n  if(FALSE && TRUE){\n    get_model_with_coeff(price~  I(carat^   2) + cut  + carat*table, data= ggplot2::diamonds)\n  }\n}\n\n\n\nget_model_with_raw = function(model,data = NULL){\n  # depend on get_model_pair\n\n  #' get a list of model vars with their corresponding raw vars.\n  #'\n  #' @export\n  #' @description a warp up function of \\code{\\link{get_model_pair}}\n  #' @details See \\code{\\link{get_model_pair}}\n  #'\n  #' @param model, See \\code{\\link{get_model_pair}}\n  #' @param data, See \\code{\\link{get_model_pair}}\n  #' @return a list with names as model vars and elements as their raw coeff\n\n\n\n  return(get_model_pair(model = model, data=data, pair_with = 'raw'))\n\n  if(FALSE && TRUE){\n    get_model_with_raw(price~  I(carat^   2) + cut  + carat*table, data= ggplot2::diamonds)\n  }\n}\n\n\n\nget_x_all = function(model,\n                     data = NULL\n){\n\n  # from attach_load_first.R\n\n  # depend on get_model_pair\n  # output is a data.frame, a unique combinations of model vars, coeff vars and raw vars\n\n  #' a unique combinations of model vars, coeff vars and raw vars\n  #'\n  #' @export\n  #' @details For the differences between raw var, model var, and coeff var: see \\code{\\link{get_x}}\n  #'\n  #' @param model \\code{lm} or \\code{glm}\n  #' @param data  NULL (default) or data.frame, a new dataset to evaluate the categorical variables.\n  #' If NULL, then use the data used in model itself.\n  #' @return a data.frame, a unique combinations of model vars, coeff vars and raw vars\n  #' See \\code{\\link{get_x}} for the meaning of \\code{model var}, \\code{coeff var} or \\code{raw var}.\n  #'\n  #'\n  #' The column \\code{'n_raw_in_model'} is a numeric field showing how many raw variables are in the corresponding model variables.\n  #' For example, the model variable 'I(carat*table)' contains two raw variables: 'carat' and 'table'. See example code for details.\n\n\n  List_raw = get_model_pair(model, data, 'raw')\n  List_coeff = get_model_pair(model, data, 'coeff')\n\n  result = NULL\n  for (i in names(List_raw)){\n\n    raw =  List_raw[[i]]\n\n    for (r in raw){\n      result = rbind(result,\n                     data.frame(raw = r, model = i, coeff = List_coeff[[i]],stringsAsFactors = FALSE)\n      )\n    }\n  }\n  # result$coeff\n  result$raw = as.character(result$raw)\n  result$model = as.character(result$model)\n  result$coeff = as.character(result$coeff)\n\n\n  n_raw_in_model = (result$model == result$raw)*1\n  n_raw_in_coeff = (result$coeff == result$raw)*1\n\n  if (sum(!n_raw_in_model)){\n    for (i in  (result$model[!n_raw_in_model] %>% unique)\n    ){\n      # i =  (result$model[!n_raw_in_model] %>% unique)[1]\n      position = (result$model == i)\n      n_raw_in_model[position] = position %>% result$raw[.] %>% unique %>% length\n    }\n  }\n  #\n  #   if (sum(!n_raw_in_coeff)){\n  #     for (i in  (result$coeff[!n_raw_in_coeff] %>% unique)\n  #     ){\n  #       # i =  (result$coeff[!n_raw_in_coeff] %>% unique)[1]\n  #       position = (result$coeff == i)\n  #       n_raw_in_coeff[position] = position %>% result$raw[.] %>% unique %>% length\n  #     }\n  #   }\n\n  return(cbind(result,n_raw_in_model))\n\n  if(FALSE && TRUE){\n    get_x_all(model = price~  I(carat^   2) + cut  + I(carat*table),data = ggplot2::diamonds)\n\n\n    #________ irregular formulas\n    model_dirty = lm(price~  I(carat^   2) + cut  - carat:table - cut ,ggplot2::diamonds)\n    test = get_x_all(model_dirty)\n\n    test\n    test$coeff\n    # ______  errors _______________\n\n    tryCatch(get_x_all(model = price~  I(carat^   2) + cut  + I(carat*table)),\n             error = function(x){\n               print(x)\n             })\n\n  }\n\n}\n\n\n\n\n\n###  Model Functions  -------------------\n\n\n\nget_valid_rows = function(model, # glm or lm or a formula\n                          data # data.frame\n){\n  # from attach_load_first.R\n\n  # this function will return the TRUE or FALSE for each observation in the dataset\n  # that can be used in the model fit/prediction.\n\n  #' identify missing rows for model/formula.\n  #'\n  #' @export\n  #' @details Data often contains missing values and \\code{lm()} or \\code{glm()} often skip those rows.\n  #' This function is to identify which rows that \\code{lm()} or \\code{glm()} skips.\n  #'\n  #' @param model  a formula or an output of lm or glm\n  #' @param data  the data.frame supposed to be used in modelling\n  #' @return a boolean vector with same length as the number of rows of data, with TRUE if a row has full data for the modelling and FALSE if not.\n\n\n  vars = c(get_x(model,method = 'raw'), get_y(model,method = 'raw'))\n  is_in_data = vars %in% colnames(data)\n  if (sum(is_in_data)<length(is_in_data)){\n\n    stop(\"variables below in the model are not in the data \\n  \",\n         vars[!is_in_data]\n    )\n  }\n\n\n  return(data[,vars] %>% complete.cases)\n\n  if (FALSE && TRUE){\n\n    model = lm(price ~ carat, head(ggplot2::diamonds,1000))\n    data = head(ggplot2::diamonds,10)\n\n    # so observation 1, 4, 7 will be not valid rows\n    data[c(1,4,7),\"price\"] = NA\n    data\n    get_valid_rows(model,data)\n\n    # error message as no \"price\" is found in the data\n    data[,\"price\"] = NULL\n    tryCatch(get_valid_rows(model,data),\n             error = function(x){\n               print(x)\n             })\n  }\n}\n\n\n\n###### Advanced Functions ===============\n\n\nfocusing_var_coeff = function(model,\n                              focus_var_coeff = NULL,\n                              focus_var_raw = NULL,\n                              intercept_include = TRUE,\n                              data = NULL\n){\n\n  # an attach_Load_First.R function\n\n  # make all the coefficients into 0 except the variables you want to focus\n  # used to measure impacts of certain varia\n\n\n  #' focusing on selected variables in the model, and eliminating impacts from other variables.\n  #'\n  #' @export\n\n  #' @details In a model \\code{y ~ a + b}. Sometimes you want to fix value of \\code{a} and see the variations of \\code{b} in \\code{y}.\n  #' The most straightforward way to code this, as we did in this function, is to make \\code{a}'s coefficients as 0, and then use the predict().\n  #'\n  #' @param model  an output of lm or glm\n  #' @param data  optional, a new dataset to evaluate the categorical variables.\n  #' If NULL, then use the data used in model itself.\n  #' @param focus_var_coeff  NULL or a character vector, choose coeff vars you want to focus. The unselected vars will have coeff values as 0.\n  #' Default is NULL, which means to choosing nothing.\n  #' @param focus_var_raw  NULL or a character vector, choose raw vars you want to focus. The unselected vars will have coeff values as 0.\n  #' Default is NULL, which means to choosing nothing.\n  #' @param intercept_include a boolean, whether to include the intercept (default is TRUE).\n  #' @return a new model with only focused vars having coeff unchanged, and all other vars having coeff as 0.\n\n\n  sanity_check(model,Class = c('lm','glm'))\n\n  if ( !is.null(focus_var_coeff) && !is.null(focus_var_raw) ){\n    stop(\"you have to provide the var names on which you want to focus.\")\n  }\n\n  # make any coeff except focus_var_coeff as 0\n  replacement = model$coefficients # model = Result\n  names(replacement) = gsub(\" \",\"\",names(replacement))\n\n\n  if ( !is.null(focus_var_coeff)){\n\n    sanity_check(focus_var_coeff, exact_in_match = names(replacement) )\n\n    focus_var_coeff = gsub(\" \",\"\",focus_var_coeff)\n  } else if ( !is.null(focus_var_raw)){\n\n    sanity_check(focus_var_raw, exact_in_match = get_x(model,method = \"raw\") )\n\n    focus_var_raw = gsub(\" \",\"\",focus_var_raw)\n\n    x_pair = get_x_all(model, data = data)\n    x_pair = x_pair[x_pair$raw %in% focus_var_raw,]\n    focus_var_coeff = unique(x_pair$coeff)\n  }\n\n\n\n  if (intercept_include) focus_var_coeff = c(focus_var_coeff,\"(Intercept)\")\n\n  # focus_var_coeff = '(Intercept)'\n  replacement[!names(replacement) %in% focus_var_coeff] = 0\n\n\n  model$coefficients = replacement\n\n  return(model)\n\n  if (FALSE && TRUE){\n    focus_var_raw  = 'carat'\n\n    model = lm(price~ cut + carat + I(carat^2) + I(carat^3) +\n                 I(carat  * depth) + depth,ggplot2::diamonds)\n    # all coeffs except carat's will be 0\n    focusing_var_coeff(model, focus_var_coeff = 'carat')\n    # all coeffs except cut.L's will be 0\n    focusing_var_coeff(model, focus_var_coeff = 'cut.L')\n    # all coeffs without raw vars cut or carat will be 0\n    focusing_var_coeff(model, focus_var_raw = c('cut','carat'))\n\n    # if you didn't specify anything, then all vars' coeff will become 0 except intercept\n    focusing_var_coeff(model)\n\n\n    # if cannot find the focus_var_coeff or focus_var_raw in the model\n    tryCatch(focusing_var_coeff(model, focus_var_coeff = 'caratdsd'),\n             error = function(err) warning(err))\n    tryCatch(focusing_var_coeff(model, focus_var_raw = '3213'),\n             error = function(err) warning(err))\n\n  }\n}\n\n\n\n\n\n\n\neffect = function( model,\n                   data = NULL,\n                   focus_var_raw , # must be the raw vars in the model\n                   focus_var_coeff = NULL,   # must be the coeff vars in the model\n                   focus_var_model = NULL,   # must be the model vars in the model\n\n                   focus_value = NULL,\n                   # a list, each element of the list must have names in focus_var_raw,\n                   # and contains at least 2 values of the key coeff vars\n                   # at least 2 values shall be provided, as we want to get the effects of it on the dependent\n                   nonfocus_value = NULL,\n                   # a list, each element of the list must have names in non focus_var_raw,\n                   # and contain at most 1 values of the key coeff vars\n                   # only one value can be provided, as we want to fix those non focus vars.\n                   transform_y = NULL, # a function on y (ex. log(y) )\n                   PRINT = TRUE,\n                   PLOT = TRUE,\n                   Reverse = FALSE, # when plot, whether to use reverse order in x-axis (ex. for balance_left)\n                   bar_plot = NULL, # choose bar plot or line plot\n                   intolerance_on_wrong_names = FALSE\n){\n\n  # an attach_Load_First.R function\n\n  # Main usage:: check the effects of the key raw variable (key_focus), focus_var_raw[1], on the dependent.\n  # If focus_var_raw[2] exists, then we call it non-key focus raw var,\n  # then we will check the effects of the first raw var under different values of the second raw.\n\n  # the function will also check if the dependent vars is monotonic under different values of the key_focus\n  # if focus_var_raw[2] exists, then we will check if it is monotonic under different values of focus_var_raw[2]\n\n  # you can also focus on effects of key_focus (focus_var_raw[1]) through only certain coeff vars.\n  # you need specify those coeff vars, focus_var_coeff in the arguments. then all other coeff vars unspecified will have coeff 0\n  # by default, focus_var_coeff is null, which means we will check effect of key_focus on all coeff vars.\n\n  # same as focus_var_model\n\n  # by default, effects of key_focus through its value seq(0.05,0.95,by = 0.05) quantities will be shown.\n  # you can also provide values of all raws through argument focus_value (for focus_var_raw), and nonfocus_value for non-focus var\n  # by default, for all non-key non_focus raw vars, we assume their values are fixed at mean (if numeric) or mode (if factor or character) .\n\n  # what is \"raw var\" / \"model var\" and \"coeff var\"\n  # in price ~ I(carat * depth) + I(carat>1), carat and depth are raw, but not model var,\n  # \"model vars\" here are \"I(carat * depth)\" and \"I(carat>1)\"\n  # \"coeff vars\" here are \"I(carat * depth)\" and \"I(carat>1)TRUE\"\n  # \"coeff vars\" only exist after running the model\n  # \"raw vars\" and \"model vars\" exist when formula is created.\n\n\n\n  # preg = model =  glm(case ~ I(age>35) + spontaneous, data = infert,family = \"binomial\")\n  # data = infert\n\n\n  #' evaluate the marginal effects of the selected raw variable on the dependent.\n  #'\n  #' @export\n  #' @details This function will evaluate marginal impacts and show the monotonicity of marginal impacts of\n  #' a selected variable on the dependent.\n  #'\n  #' Note that the marginal impacts is not simply the sign of coeff: In a model like \\code{y~ x + x^2 + p + q},\n  #' marginal impacts of \\code{x} on \\code{y} requires an evaluation of both \\code{x} and \\code{x^2} at the same time.\n  #'\n  #' Here the \\code{focus_var_raw} is \\code{x}, \\code{focus_var_coeff} are \\code{x} and \\code{x^2}\n  #' \\code{nonfocus_value} is \\code{p} and \\code{q}\n  #'\n  #' Also the monotonicity of marginal impacts of \\code{x} will be different for different range of \\code{x}'s values.\n  #'\n  #' Another interesting case is when \\code{x} is interacting with other variables, then its marginal impacts will also\n  #' be dependent on the values of those interacted variables.\n  #'\n  #' Level of marginal impacts: To make the level of marginal impacts of \\code{x} realistic, by default we fixed all other right-hand-side variables\n  #' fixed at their mean (numeric) or mode (character or factor). You can also provide fixed values for them.\n  #' Also by default we let the interested variable (focused raw var) \\code{x} to vary between its \\code{seq(0.05,0.95,by = 0.05)} quantiles.\n  #'\n  #' This function will take care those cases above and make evaluating marginal impacts easier.\n  #'\n  #'\n  #' @param model  an output of lm or glm\n  #' @param data  NULL (default) or a data.frame, a new dataset to evaluate the categorical variables.\n  #' If NULL, then use the data used in model itself.\n  #' @param focus_var_raw  NULL or a character vector with maximum length of 2, in which you can choose \\code{raw vars} you want to focus.\n  #' See \\code{\\link{get_x}} for the meaning of \\code{raw var}.\n  #'\n  #' \\itemize{\n  #' \\item If there is only one raw var in the vector \\code{focus_var_raw}, then we will check the marginal impact of that raw var.\n  #' \\item If there is only two raw vars in the vector \\code{focus_var_raw}, then we\n  #' will check the marginal impact of the FIRST raw var (\\code{focus_var_raw[1]}) under different values of SECOND raw var (\\code{focus_var_raw[2]}).\n  #' }\n  #'\n  #' See the example code for details.\n  #'\n  #' @param focus_var_coeff  NULL or a character vector. Must be \\code{coeff vars} containing \\code{focus_var_raw[1]}.\n  #' See \\code{\\link{get_x}} for the meaning of \\code{coeff var}.\n\n  #' After you set up the \\code{focus_var_raw}, you can also choose to focus on effects of \\code{focus_var_raw[1]} through only certain coeff vars,\n  #' then all other unspecified coeff vars related \\code{focus_var_raw[1]} will have coeff 0\n  #' by default, focus_var_coeff is null, which means we will check effect of \\code{focus_var_raw[1]} on all coeff vars.\n  #'\n  #' See the example code for details.\n  #'\n  #' @param focus_var_model  NULL or a character vector. Must be model vars containing \\code{focus_var_raw[1]}.\n  #' See \\code{\\link{get_x}} for the meaning of \\code{model var}.\n  #' Similar use as argument \\code{focus_var_coeff}, except here you can specify which model vars you want to focus.\n  #'\n  #' See the example code for details.\n  #'\n  #' @param focus_value  NULL or a list; each element of the list must have names in focus_var_raw.\n  #' By default, we will check marginal effects of \\code{focus_var_raw[1]} through \\code{seq(0.05,0.95,by = 0.05)} quantiles of its values in the modelling data.\n  #' But you can also specify the values you want to check here. See the sample code.\n  #'\n  #' @param nonfocus_value  NULL or a list; each element of the list must have names in non-focused raw vars (not show up in \\code{focus_var_raw})\n  #' The meaning of non-focus var is: When we check the marginal effect of focus var on dependent, we let the focus var vary and fix the non-focus vars.\n  #' By default, for non-focused raw vars, we assume their values are fixed at mean (if numeric) or mode (if factor or character) in the modelling data.\n  #' But you can also specify the fixed values you want. See the sample code.\n  #'\n  #' @param transform_y  NULL or a function, used only for plot. Used as a function to recalculate y (a function on y (ex. log(y) )).\n  #' @param PRINT  a boolean, whether to print messages AND to plot.\n  #' @param PLOT a bookean, whether to plot\n  #' @param Reverse  a boolean,  whether to use reverse order in x-axis when plot. Default is FALSE.\n  #' @param bar_plot  NULL or a boolean, choose bar plot or line plot. If NULL, we will choose automatically.\n  #'\n  #' @param intolerance_on_wrong_names  a boolean. If a name is wrong, either in focus_var_raw, focus_var_model, focus_var_coeff,\n  #' focus_value or nonfocus_value, whether we delete the wrong names and go on (default), or report an error.\n\n  #' @return a list:\n  #'\\itemize{\n  #'\\item Focus_values: show the values of focus_var_raw we used to evaluate the marginal effects.\n  #'\\item data_and_predict: full dataset used to evaluate the marginal effects.\n  #'\\item summmary_glm: a summary of lm or glm model.\n  #'\\item Monoton_Increase: whether the marginal impact is Monotonic Increase.\n  #'\\item Monoton_Decrease: whether the marginal impact is Monotonic Decrease.\n  #' }\n\n\n  ### ------------------------   prepare\n\n  if (is.null(data)) {\n    data = get_data_from_lm(model)\n    if (is.null(data)) stop('data is not provided and not found in model')\n  }\n  data = data.frame(data)\n\n  # get_model_pair(model)\n  x_pair = get_x_all(model, data = data)\n\n  all_raw_var = x_pair$raw %>% unique\n  all_coeff = x_pair$coeff %>% unique\n  all_model = x_pair$model %>% unique\n\n  # all the coeffs that contains the focus_raw\n  all_focus_coeff = x_pair[x_pair$raw %in% focus_var_raw[1],]$coeff %>% unique\n  # all the model that contains the focus_raw\n  all_focus_model = x_pair[x_pair$raw %in% focus_var_raw[1],]$model %>% unique\n\n  y = get_y(model,\"coeff\")\n  names(model$coefficients) = gsub(\" \",\"\",names(model$coefficients)) # standardized the names\n\n\n  ### ------------------------   check\n\n  # check focus_var_raw\n  if (intolerance_on_wrong_names) {\n    sanity_check(focus_var_raw, exact_in_match = all_raw_var)\n  } else {\n    focus_var_raw =  check_names_delete(focus_var_raw, all_raw_var, STOP = FALSE, PRINT = PRINT,\n                                        tobechecked_name = 'focus_var_raw',\n                                        checking_name = 'all_raw_var',default_value = NULL)\n    if (is.null(focus_var_raw)) stop('focus_var_raw is missing!')\n  }\n  # check focus_var_coeff\n\n  if (!is.null(focus_var_coeff)){\n\n    # is.vector(focus_var_coeff)\n    if (intolerance_on_wrong_names) {\n      sanity_check(focus_var_coeff,exact_in_match = all_focus_coeff)\n    } else {\n      focus_var_coeff =  check_names_delete(focus_var_coeff, all_coeff, STOP = FALSE,PRINT = PRINT,\n                                            tobechecked_name = 'focus_var_coeff',\n                                            checking_name = 'coeff vars',default_value = NULL)\n    }\n  }\n\n  if (!is.null(focus_var_model)){\n    # is.vector(focus_var_model)\n    if (intolerance_on_wrong_names) {\n      sanity_check(focus_var_model,exact_in_match = all_focus_coeff)\n    } else {\n      focus_var_model =  check_names_delete(focus_var_model, all_model, STOP = FALSE,PRINT = PRINT,\n                                            tobechecked_name = 'focus_var_model',\n                                            checking_name = 'model vars',default_value = NULL)\n    }\n  }\n\n\n\n\n\n  if (sum(colnames(data) %in% all_raw_var) < length(all_raw_var)) stop(\"data provided is missing some raw vars for this regression\")\n\n\n  if (length(nonfocus_value)) {\n    sanity_check(nonfocus_value, Class = 'list')\n\n    if (intolerance_on_wrong_names) {\n      sanity_check(names(nonfocus_value), exact_in_match = all_raw_var)\n    } else {\n\n      # nonfocus_value = list('cut' = 1, 'dwewsdfds' = 2); all_raw_var = 'cut'\n      # nonfocus_value = list('cudasdst' = 1, 'dwewsdfds' = 2); all_raw_var = 'cut'\n\n      nonfocus_value =  check_names_delete(nonfocus_value, all_raw_var, STOP = FALSE,PRINT = PRINT,\n                         tobechecked_name = 'nonfocus_value',\n                         checking_name = 'all_raw_var',default_value = NULL)\n    }\n\n    for (x in nonfocus_value){\n      sanity_check(x, exact_length = 1, message_provided = \"Only 1 value can be provided for each non-focus vars\")\n    }\n  }\n\n  if (length(focus_var_raw)>2) stop(\"You can only focus on at most two variables\")\n\n  if (length(focus_value)) {\n    sanity_check(focus_value, Class = 'list')\n    if (intolerance_on_wrong_names) {\n      sanity_check(names(focus_value), exact_in_match = all_raw_var )\n    } else {\n      focus_value =  check_names_delete(focus_value, all_raw_var, STOP = FALSE,PRINT = PRINT,\n                                           tobechecked_name = 'focus_value',\n                                           checking_name = 'all_raw_var',default_value = NULL)\n    }\n\n    for (x in focus_value){\n      sanity_check(x,min_oberserv = 2,\n                   message_provided = 'The provided values for each focus raw var shall at least have to different values to enable monoton comparison')\n    }\n  }\n\n  if (length(transform_y)) sanity_check(transform_y, Class = 'function')\n\n\n  ### ------------------------    values for non-focus variables\n\n  #   llply(ggplot2::diamonds,function(x){\n  #      print(paste( class(x),collapse=' '))\n  #   })\n\n  ##~~~~~~~~   get the mean or mode for all raw vars : used for prediction\n\n  all_raw_values = list()\n  for ( each_raw_var in all_raw_var) {\n    x = data[,each_raw_var]\n    Class = paste( class(x),collapse=' ')\n\n    if ( Class %in% c(\"numeric\",\"integer\")){\n      all_raw_values[[each_raw_var]] = mean(x)\n    } else {\n      # for factor or character, we assume Mode\n      all_raw_values[[each_raw_var]] = Mode(x)\n    }\n  }\n\n  # if you provide the values to the non-focus vars, then replace the mean/mode by the provided ones.\n  if (length(nonfocus_value)){\n    for( x in names(nonfocus_value)){\n      all_raw_values[[x]] = nonfocus_value[[x]]\n    }\n  }\n\n  ### get the valueS for focus raw vars\n  # if numeric:\n  # get seq(0.015,0.95,0.3 ) quantile values for the non-key focus vars\n  # get seq(0.015,0.95,0.05 ) quantile values for the key focus vars\n  # if not : like factor\n  # get the unique values\n\n  is_factor_key  = c(1,1)\n  names(is_factor_key) = focus_var_raw\n  i=1\n\n  for( x in focus_var_raw){\n    # x = focus_var_raw[1]\n\n    # to see whether focus_vars are factors/characters\n    is_factor_key[x] = sum(c(\"factor\",\"character\") %in% class(all_raw_values[[x]] ))\n\n    if (x %in% names(focus_value)) {\n      # if values are provided for focus variables\n      all_raw_values[[x]] = focus_value[[x]]\n\n    } else if ( # if not provided, and x is a factor/category\n      is_factor_key[x]\n    ){\n      # for factors and characters, just get unique values\n      all_raw_values[[x]] =  focus_value[[x]] = unique(data[,x])\n\n    } else if ( i== 2 & is_factor_key[1]) { # for numerics\n      # if the first focus var is a factor/character, and second focus var is a numeric,\n      # then we just don't need a very detailed quantile for the second one\n      # i = 2\n      all_raw_values[[x]] =  focus_value[[x]] =   unique(quantile(data[,x],seq(0.015,0.95,0.3 )))\n    } else {\n      all_raw_values[[x]] =  focus_value[[x]] =   unique(quantile(data[,x],seq(0.015,0.95,0.05 )))\n    }\n    i = i + 1\n  }\n\n\n\n  # ________ prepare data for predict() _____________\n\n  # this will keep the class\n  modeled_data = expand_grid(all_raw_values, stringsAsFactors = FALSE)\n  # modeled_data[,1] %>% class\n  model_use = model\n  corresponding_coeff = x_pair[x_pair$raw %in% focus_var_raw[1],\"coeff\"] %>% unique\n\n  # if you only focus the effects of certain coeff vars,\n  # then assign all other focus_raw related coeff vars to 0\n\n  if (!is.null(focus_var_coeff)){\n\n    corresponding_coeff = focus_var_coeff\n\n    coeff_to_delete = all_focus_coeff[!all_focus_coeff %in% focus_var_coeff]\n    coeff_to_include = all_coeff[!all_coeff %in% coeff_to_delete]\n    model_use = focusing_var_coeff(model,coeff_to_include)\n  }\n\n  # if you only focus the effects of certain coeff vars,\n  # then assign all other focus_raw related coeff vars to 0\n  if (!is.null(focus_var_model)){\n    corresponding_coeff = x_pair[x_pair$model %in% focus_var_model,\"coeff\"] %>% unique\n\n    sanity_check(focus_var_model,exact_in_match = focus_var_model)\n\n    model_to_delete = all_focus_model[!all_focus_model %in% focus_var_model]\n\n    coeff_to_delete = x_pair[x_pair$model %in% model_to_delete,\"coeff\"] %>% unique\n    coeff_to_include = x_pair[!x_pair$coeff %in% coeff_to_delete,\"coeff\"] %>% unique\n\n    model_use = focusing_var_coeff(model_use,focus_var_coeff = coeff_to_include)\n  }\n\n  if (!is.null(focus_var_coeff) && !is.null(focus_var_model)){\n    corresponding_coeff = x_pair[x_pair$model %in% focus_var_model,\"coeff\"] %>% unique\n    if (length(union(corresponding_coeff,focus_var_coeff)) == 0) stop(\"focus_var_coeff and focus_var_model have no common variables.\")\n  }\n\n  # ------------------- Prediction ~~~~~~~~~~~~~~~~~~~~~~~~```\n\n\n  # if formula is dirty, then the predict will now work\n  if (\n    sum(\n      (get_x_hidden(model_use) %in% colnames(modeled_data))==0\n    )\n  ){\n    model_use = glm(paste_formula(model_use,clean = TRUE) %>% as.formula, data = data, family = family(model_use))\n  }\n\n  predicted =  data.frame(predict = predict(model_use,newdata = modeled_data,type='response'),\n                          modeled_data,\n                          stringsAsFactors = FALSE)\n\n  ###_____  check the monotonicity ________\n\n  # when there is only one focus var: the key\n  if (length(focus_var_raw) ==1 ) {\n    predicted = predicted[order(predicted[,focus_var_raw[1]]),]\n    monoton_increase = is_increase(predicted$predict)\n    monoton_decrease = is_decrease(predicted$predict)\n  }\n\n  # when there are focus vars: the key and non-key, we check the monotonic effect under each value of the non-key\n  if (length(focus_var_raw) ==2 ) {\n\n    predicted = predicted[\n      order(\n        predicted[,focus_var_raw[2]],predicted[,focus_var_raw[1]]\n      ),]\n\n    unique_key_focus = unique(predicted[,focus_var_raw[2]])\n\n    monoton_increase = laply(unique_key_focus, function(x){\n      is_increase(predicted[predicted[,focus_var_raw[2]] ==x, ]$predict)\n    })\n\n    monoton_decrease = laply(unique_key_focus, function(x){\n      is_decrease(predicted[predicted[,focus_var_raw[2]] ==x, ]$predict)\n    })\n\n    names(monoton_decrease) = unique_key_focus\n    names(monoton_increase) = unique_key_focus\n\n  }\n\n\n  # ------------------- For Plot ~~~~~~~~~~~~~~~~~~~~~~~~```\n\n  plot_data = predicted\n\n  # whether the target variable needs some transform function?\n  if (!is.null(transform_y)){\n    plot_data$predict =  predicted$predict = transform_y(plot_data$predict)\n  }\n\n  # initialize the graph\n  graph = NULL\n\n  # if the key focus var only has at most 10 unique values, then transfer it to factor when plot\n  if (PRINT & PLOT){\n    x_title = paste(corresponding_coeff,collapse = '+')\n    graph_title = paste('marginal impacts of ', focus_var_raw[1], ' on ', y, sep='')\n\n    Length_Unique = plot_data[,focus_var_raw[1]] %>% unique %>% length\n\n    # if bar_plot is not provided\n    if (is.null(bar_plot)){\n      if  (\"numeric\" %in% class(plot_data[,focus_var_raw[1]])){\n        bar_plot = FALSE\n      } else {\n        bar_plot = TRUE\n      }\n    }\n\n    # if bar_plot is TRUE and suitable, then transform the key var into factor\n    if (bar_plot) {\n      plot_data[,focus_var_raw[1]] = as.factor(plot_data[,focus_var_raw[1]])\n      is_factor_key[1] = 1\n    }\n\n    # plot according to number of focus variables\n    if (length(focus_var_raw) ==1 ) {\n\n      if (bar_plot && is_factor_key[1]>0){\n        # if it is a character, then use bar to plot\n        graph =\n          ggplot(plot_data) + geom_bar(aes_string(x=focus_var_raw[1], y = 'predict'),stat = \"identity\")\n      } else {\n        graph =\n          ggplot(plot_data) + geom_line(aes_string(x=focus_var_raw[1], y = 'predict'))\n      }\n    }\n    #\n\n    if (length(focus_var_raw)==2) {\n\n      Class_col = paste( class(plot_data[,focus_var_raw[2]]),collapse=' ')\n\n      if (!is_factor_key[2]) { # transfer the secondary key into factor\n        plot_data[,focus_var_raw[2]] = as.factor(plot_data[,focus_var_raw[2]])\n      }\n\n      if (bar_plot && is_factor_key[1] ){\n        graph = ggplot(plot_data) + geom_bar(aes_string(x=focus_var_raw[1],\n                                                        fill = focus_var_raw[2],\n                                                        y = 'predict'),\n                                             stat = \"identity\")\n\n      } else {\n        graph = ggplot(plot_data) +\n          geom_line(aes_string(x=focus_var_raw[1], colour = focus_var_raw[2], y = 'predict'))\n      }\n\n    }\n\n    # if logit or probit, then y shall be percentage\n    if (\n      !(\"lm\" %in% class(model)) &&\n      model$family$link %in% c(\"logit\",\"probit\")\n    ) {\n      graph = graph + scale_y_continuous(labels = percent)\n    }\n\n    graph = graph + labs(y=y, x = x_title, title = graph_title)\n\n\n    if (Reverse && is_factor_key[1] == 0) {graph = graph + scale_x_reverse()} # factor cannot use reverse\n\n    print(graph)\n  }\n\n\n\n  Coeff_table = data.frame(Var = names(model_use$coefficients) ,\n                           coeff_value = model_use$coefficients,\n                           stringsAsFactors = FALSE)\n  rownames(Coeff_table) = NULL\n\n  return(list(\n    Focus_values = focus_value,\n    data_and_predict = predicted,\n    summmary_glm = Coeff_table,\n    Monoton_Increase = monoton_increase,\n    Monoton_Decrease = monoton_decrease  ))\n\n\n  if (FALSE && TRUE) {\n    ##___ unit test ____\n\n    # __________________  One Dimension: the most basic case ____________________\n\n\n\n    set.seed(413)\n    traing_data = ggplot2::diamonds[runif(nrow(ggplot2::diamonds))<0.05,]\n    nrow(traing_data)\n\n    diamond_lm3 = lm(price~ cut + carat + I(carat^2) +\n                       I(carat^3) + I(carat  * depth) + cut:depth, traing_data) # a GLM\n\n    # more carats, higher price.\n    effect(model = diamond_lm3,\n           data = traing_data,\n           focus_var_raw = c('carat'),\n           Reverse = TRUE) # value in x-axis is reverse\n\n    # focus on only 'I(carat^3)', which means we will make all other coeff,\n    # including 'carat' and 'I(carat^2)' into 0\n    effect(model = diamond_lm3,\n           data =traing_data,\n           focus_var_raw =c('carat'),\n           focus_var_coeff = 'I(carat^3)')\n    # __________________  One Dimension: Categorical ____________________\n\n    # selected model-var to focus: here not focus on cut:depth, only focus on cut\n    suppressWarnings(\n      effect(model = diamond_lm3,\n             data = traing_data,\n             focus_var_raw = c('cut'),\n             focus_var_model = 'cut'\n             )\n      )\n\n    # __________________  Double Dimensions ____________________\n\n    # here focus_var_raw has two values: \"carat\" and \"cut\"\n    # that means we will evaluate impact of \"carat\" on \"price\" through different value of \"cut\"\n\n    effect(model = diamond_lm3,data = traing_data, focus_var_raw=c('carat',\"cut\"))\n\n    # __________________  Provide Values to Focused vars  ____________________\n\n    # when evaluating impacts,\n    # we can provide the range of values for key variables\n\n    effect(model = diamond_lm3,data = traing_data,\n           focus_var_raw = c('carat',\"cut\"),\n           focus_value = list(carat=seq(0.5,6,0.1)))\n\n  }\n}\n\ndeleting_wrongeffect = function (model , # a GLM model\n                                 focus_var_raw = NULL,  # see Effect()\n                                 focus_var_model= NULL,   # see Effect()\n                                 Monoton_to_Match = 1,  # 1 means you want monotonic increasing marginal effect, -1 means negative\n                                 # the correct signs\n                                 family = NULL,\n                                 re_estimate = TRUE, # if find the wrong marginal effect, whether to delete the wrong coeff and re-estimate the model\n                                 data,\n                                 STOP = FALSE, # stop at key checking point\n                                 PRINT = TRUE,\n                                 PLOT = TRUE,\n                                 ...){\n\n  # this function will check whether the marginal effect of certain raw var in a model is correct.\n  # You have to read the function effect() to understand how to get the marginal effect\n\n  # note that a raw variable. for example \"carat\" will wield its impact\n  # through its corresponding coeff variables, like  c(\"I(carat^4)\",\"I(carat^3)\") etc\n\n  # if re_estimate == TRUE, then we will\n  # 1. drop the first coeff from focus_var_model\n  # 2. revaluate the model, then check the marginal effect\n  # repeat the two steps above until we get correct marginal effect or we delete all coeffs in focus_var_model.\n\n\n  # model = diamond_lm\n  # focus_var_raw = \"carat\"\n  # focus_var_model =  c(\"I(carat^4)\",\"I(carat^3)\")\n\n\n  #' check monotonicity of marginal impacts and re-estimate the model.\n  #' @description check monotonicity of marginal impacts and re-estimate the model (optional) until we get correct marginal impacts.\n  #' @export\n  #' @details This function first calls function \\code{\\link{effects}}\n  #' and then checks the monotonicity of marginal impacts. If the direction of marginal impacts are incorrect,\n  #' it can delete a model var that potentially causes the wrong marginal impacts and then re-estimate the model.\n  #' We will keep doing this until the correct marginal impacts are found\n  #'\n  #' Details of evaluating the marginal impacts \\code{\\link{effects}}\n  #'\n  #' @param model, an output of lm or glm\n\n  #' @param focus_var_raw  see \\code{\\link{effects}}.\n  #' @param focus_var_model  see \\code{\\link{effects}}.\n  #'\n  #'\n  #' @param PRINT  a boolean, whether to print messages and to plot.\n  #' @param PLOT  a boolean, whether to plot.\n  #' @param Monoton_to_Match  1 or -1. 1 means you want monotonic increasing as the correct marginal effect, -1 means negative\n  #' @param re_estimate  a boolean with default as TRUE. This is to decide\n  #' if the marginal impacts are found to be incorrect, then whether to delete a model var that\n  #' potentially cause the wrong marginal impacts and re-estimate the model\n\n  #' @param data  optional, a new dataset to show the marginal impacts and re-estimate the model.\n  #' If NULL, then use the data used in model itself.\n  #'\n  #' @param STOP  a boolean. When find a model with incorrect marginal impacts, whether to stop there and wait to continue (call the \\code{\\link{Enter_to_Continue}})\n  #' @param family  family of glm, for example, can be gaussian \\code{\"(link = 'identity')\"}  or \\code{\"(link = 'logit')\"}.\n  #' If NULL, we will use the default family of the model\n  #' @param ...  additional arguments going to \\code{\\link{effect}}\n  #'\n  #' @return a model (\\code{lm} or \\code{glm}).\n  #' \\itemize{\n  #' \\item If re_estimate == TRUE, then return will be an re-estimated model with correct marginal impacts given we can find one.\n  #' \\item If re_estimate == FALSE, original model will be returned.\n  #'}\n\n\n  ### __________________  initialize __________________\n  if (is.null(family)) family = family(model)\n  if (is.null(data)) {\n    data = get_data_from_lm(data)\n    if (is.null(data)) stop ('data is not provided and cannot be found in the model')\n  }\n  data0 = data.frame(data)\n\n  # for raw vars\n  all_var_raw = get_x(model) # model= Result\n  in_raw = focus_var_raw %in% all_var_raw\n\n  if (FALSE %in% in_raw) {\n    if (PRINT) cat(\"raw_var \", paste( focus_var_raw[!in_raw], collapse = ', '),\", cannot be found in the model, so skip the check for it. Nothing changed. \\n\\n\")\n    return(model)\n  }\n\n  # for coeff vars\n  if (is.null(focus_var_model)){\n    # if focus_var_model NOT Provided,\n    # then get all coeff-var that contains the raw-var as the focus_var_model\n\n    x.all = get_x_all(model)\n    focus_var_model = x.all[(x.all$raw == focus_var_raw),'model'] %>% unique\n\n  } else {\n\n    all_var_model = get_x(model,method = \"model\")\n    focus_var_model = gsub(\" \",\"\",focus_var_model)\n    focus_var_model = unique(focus_var_model)\n\n    in_model = focus_var_model %in% all_var_model\n\n\n    # check whether focus_var_raw and print_focus_car_coeff exist in the model\n    if (length(focus_var_raw) ==0 ){\n      cat(\"The updated focus_var_raw cannot be found in the model. Nothing changed\\n\")\n      return(model)\n\n    } else if (FALSE %in% in_model) {\n      print_focus_car_coeff = focus_var_model[!in_model]\n      print_focus_car_coeff = print_focus_car_coeff[!is.na(print_focus_car_coeff)]\n      cat(\"\\ncoeff var: \", paste(print_focus_car_coeff ,collapse = ', '),\n              \" cannot be found in the model, So not check them \\n\")\n\n    }\n    focus_var_model = focus_var_model[in_model]\n  }\n  if (length(focus_var_model)==0){\n    cat('\\n nothing has been checked; original model is returned.')\n    return(model)\n  }\n\n  ### __________________  each time just delete one variable _________________\n\n  control_var = 1\n  focus_var_model_0 = rev(focus_var_model)\n\n  if (re_estimate) {\n    max_steps = length(focus_var_model_0)\n    # stop if find the correct effect or run out of the focus_var_model_0\n  } else {\n    max_steps = 1 # if not re_estimate, then stop after the first step\n  }\n\n  while (control_var <= max_steps ){\n\n    # Result$family\n\n    var_tobe_checked = focus_var_model_0[control_var] # this is the model_var you prepare to delete if the marginal impact is wrong.\n\n\n    if (PRINT)  {\n\n      if (control_var==1) {\n        cat(\"\\ninitial model: \\n\")\n        print(summary(model)$coefficient[,c(1,4)])\n      }\n\n      cat('\\n\\n')\n      cat(\"check raw var: \",focus_var_raw[1],'\\ncheck model var: ', paste(focus_var_model,collapse = \", \"),'\\n')\n      if (Monoton_to_Match == 1) {\n        Monotonicity = 'Increasing'\n      } else {\n        Monotonicity = 'Decreasing'\n      }\n      cat(\"Correct Monotonicity is supposed to be: \",Monotonicity,'\\n')\n    }\n\n    effect_result = effect(model = model,\n                           data = data0,\n                           focus_var_raw = focus_var_raw,\n                           focus_var_model = focus_var_model,  # be updated each time\n                           PRINT = PRINT, PLOT = PLOT,\n                           ...)\n#\n#\n#     effect_result = effect(model = model,\n#                            data = data0,\n#                            focus_var_raw = focus_var_raw,\n#                            focus_var_model = focus_var_model,  # be updated each time\n#\n#                            PRINT = PRINT,\n#                            PLOT = PLOT,\n#\n#                            focus_var_coeff = focus_var_coeff,\n#                            focus_value = focus_value,\n#                            nonfocus_value = nonfocus_value,\n#\n#                            transform_y = transform_y,\n#                            bar_plot = bar_plot\n#                            )\n#\n#     sanity_check(focus_var_coeff, exact_in_match = 'carat')\n\n    # if non-key var is provided,\n    # then we will check the marginal effects of the key-var under each non-key var\n    # thus we need to use all() to insure all values of Monoton_Increase/Monoton_Decrease ==1\n\n    if (   (Monoton_to_Match == 1 & all(effect_result$Monoton_Increase==1) ) |\n           (Monoton_to_Match == -1 & all(effect_result$Monoton_Decrease==1) )\n    ){\n      if (PRINT) cat(\"Monotonicity is correct \\n\")\n      control_var = length(focus_var_model_0) + 100 # stop\n      correct_effect_ind = 1\n    } else {\n      if (PRINT) cat(\"Monotonicity is incorrect \\n\")\n      correct_effect_ind = 0\n    }\n    ## --------------------------  Revaluate -----------------------\n\n    if ( correct_effect_ind ==0 & re_estimate){\n      if (PRINT) cat(\"Variable \",  var_tobe_checked, \" shall be deleted, and the model shall be re-estimated. \\n\")\n      if (PRINT) cat(\"-------------------------------------------------------\\n\")\n\n      model_var = get_x(model,\"model\")\n      model_var = model_var[var_tobe_checked!=model_var]\n\n      if (length(model_var)==0) model_var = \"1\" # intercept only\n\n      Formula_new = paste( paste(get_y(model,\"model\"),\"~\"),\n                           paste(model_var,collapse = '+')\n                           # be careful with multiple variables to be deleted,\n                           # so you have to collapse it\n      ) %>% as.formula\n\n      model = glm(Formula_new,data = data0,family = family)\n\n\n      ##________  update\n      focus_var_model_old = focus_var_model\n      focus_var_model = focus_var_model[!(focus_var_model %in% var_tobe_checked)]\n      control_var  = control_var + 1 # must do this after updating focus_var_model\n\n      ## update focus_var_model each time, after you delete one variable\n      # if the sign is correct or the variables_to_check cannot be found in the model, then just break the loop\n\n      if ( length(focus_var_model)==0 & correct_effect_ind==0) {\n        control_var = length(focus_var_model_0) + 100 # stop\n        if (re_estimate) if (PRINT) cat(\"\\nAll model vars with wrong sign have been deleted, nothing to check now. \\n\")\n      }\n      if  (STOP & correct_effect_ind == 0) {\n        Enter_to_Continue()\n      }\n\n      if (PRINT) {\n        cat(\"\\nNew Model: \\n\")\n        Coeffs = summary(model)$coefficient[,c(1,4)] %>% data.frame(.,stringsAsFactors = FALSE)\n        row.names(Coeffs) = gsub(\" \",\"\",row.names(Coeffs))\n\n        # identify the checked variables\n        Coeffs[,'checked']  = row.names(Coeffs) %in% focus_var_model_old\n\n        print(summary(model)$coefficient[,c(1,4)])\n      }\n\n    } else {\n      control_var = length(focus_var_model_0) + 100 # stop\n    }\n  }\n\n\n  model$correct_effect_ind = correct_effect_ind\n\n\n\n  return(model)\n\n\n  if (FALSE && TRUE){\n\n    ##\n    set.seed(413)\n    traing_data = ggplot2::diamonds[runif(nrow(ggplot2::diamonds))<0.05,]\n    nrow(traing_data)\n\n    diamond_lm3 = lm(formula = price ~ carat + I(carat^2) + I(carat^3) + cut +\n                       I(carat * depth) , data = traing_data)\n\n\n    test = deleting_wrongeffect(model = diamond_lm3,\n                                focus_var_raw = 'carat',\n                                focus_var_model = c(\"I(carat^3)\",\"I(carat*depth)\",\n                                                    \"I(carat^2)\",\"I(carat)\"),\n                                focus_value = list(carat=seq(0.5,6,0.1)),\n                                data = traing_data,\n                                PRINT = TRUE,STOP = FALSE,\n                                Reverse = FALSE)\n\n\n    ## two focus on vars\n    test =\n      deleting_wrongeffect(model = diamond_lm3 ,\n                           focus_var_raw = c('carat',\"cut\"),\n                           focus_var_model = c(\"I(carat*depth)\",\"I(carat^3)\"),\n                           focus_value = list(carat=seq(0.5,6,0.1)),\n                           data = traing_data,PRINT = TRUE,STOP =FALSE)\n\n    diamond_lm3 = lm(formula = price ~ cut + depth +\n                       I(carat * depth) , data = ggplot2::diamonds)\n    ##  negative signs\n    deleting_wrongeffect(model = diamond_lm3 ,\n                         focus_var_raw = c('depth',\"cut\"),\n                         focus_var_model = c(\"depth\"),Monoton_to_Match = -1,\n                         data = ggplot2::diamonds,PRINT = TRUE,STOP =FALSE)\n\n    ## wrong variables names\n    deleting_wrongeffect(diamond_lm3, focus_var_raw = 'carat',\n                         focus_var_model = c(\"I(cara79t^3)\"),\n                         data = ggplot2::diamonds,PRINT = TRUE)\n\n    deleting_wrongeffect(diamond_lm3, focus_var_raw = 'carat890',\n                         focus_var_model = c(\"I(carat^3)\"),\n                         data = ggplot2::diamonds, PRINT = TRUE)\n\n  }\n}\n\n\n\n\nstepwise2 =function (model, # can be an glm/lm/formula,\n                     scope,\n                     trace = 1,\n                     steps = 1000,\n                     k = 2,\n                     data,\n                     family = NULL, # argument for familiy for glm\n                     IC_method = c(\"AIC\",\"BIC\"),\n                     test_suit = NULL, # see delete_wrongsign()\n                     STOP = FALSE # see delete_wrongsign()\n)\n{\n\n  #' same as \\code{step()} in R, but able to check marginal effects.\n  #'\n  #' @export\n  #' @details For each step of regression, you can first choose the models with correct marginal effect\n  #' and then choose the one with highest AIC/BIC within them\n  #'\n  #' @param model an output of \\code{lm} or \\code{glm}\n  #' @param scope,trace,steps,k   see \\code{step()}\n  #' @param family  used as the argument for \\code{family} of \\code{glm}, default is NULL, which means we will use the family imbedded in the model.\n  #' @param data  a data.frame used in regression.\n  #' @param IC_method  either 'AIC' or 'BIC', will overwrite the \\code{k} argument above.\n  #' @param STOP  whether stop and wait your response for each step.\n  #' @param test_suit  used to specify the correct marginal effect you want to check.\n  #' It is a list with names as raw variable and values as arguments of the function \\code{deleting_wrongeffect}\n  #' If NULL (default), then not check any marginal effect\n  #' See example code for details.\n\n  #' @return a stepwise-selected model. If \\code{test_suit} is specified, then the returned model is the one with highest AIC/BIC within those that get\n  #' correct marginal impact.\n  #'\n  #' The silde effect is to print a data.frame containing diagnostic informations for each step. The 'correct_effect_ind' column is a boolean vector to show\n  #' whether the model has correct marginal effect or not.\n  #'\n  #'\n\n  data = data.frame(data)\n  if (is.null(family)) family = family(model)\n\n\n  IC_method = match.arg(IC_method)\n  if (length(IC_method)>1) IC_method = IC_method[1]\n  # IC_method = \"BIC\"\n\n  if (IC_method == \"BIC\") {\n    if (k==2 & trace)  cat(\"k is overwritten as log(N)\")\n    k = log(nrow(data))\n  }\n\n  y = get_y(model, method = \"model\")\n  x_lower = get_x(scope$lower, data = data, method = \"model\")\n  # x_start has vars as union of the lower and start model\n  x_start = get_x(model = model, data = data, method = \"model\") %>% union(.,x_lower)\n  # x_upper has vars as union of the lower, start nad upper  model\n  x_upper = get_x(scope$upper, data = data, method = \"model\") %>% union(.,x_start)\n\n  step_count = 1\n  x_best = NULL\n  x_best_row = NULL\n  x_skip = NULL\n  best_model = model\n\n  while (step_count<steps){\n\n    list_upper = setdiff(x_upper,x_start) # vars to add\n    list_lower = setdiff(x_start,x_lower) # vars to delete\n\n    # x_delta: ~~~~~~~~~~~ denotations of the different models\n    # if add a var, then denote it as \"+ 'var'\", otherwise as \"- 'var'\"\n    # \"---\" is to denote the starting model in that step\n\n    x_delta = c(\"origin\",paste(\"+\",list_upper), paste(\"-\",list_lower))\n    x_delta = x_delta [!x_delta %in% c(\"+ \",\"- \")]\n\n    correct_effect_ind = nvar = IC = formula_new = NULL\n\n    # within one step, try add or delete each var\n    for (delta in x_delta ){\n      # delta = x_delta [1]\n\n      # create the formula\n      if (delta == \"origin\") {\n        formula_new[delta] = paste(y,\"~\",paste(x_start,collapse = \"+\"))\n      } else {\n        formula_new[delta] = paste(y,\"~\",paste(x_start,collapse = \"+\"),delta)\n      }\n\n      if (trace) {\n        cat('\\n',formula_new[delta],\"\\n------------------------\")\n        }\n\n      formula_new_model = as.formula(formula_new[delta])\n      new_formula = formula_new_model %>% paste_formula(.,clean = TRUE) %>% as.formula\n      new_model = glm( new_formula,data = data, family = family)\n      new_model$call$formula = new_formula\n\n      if (delta == \"origin\") {\n        best_model = new_model\n      }\n      #________________ do the test of marginal effect ________________\n\n      correct_effect_ind[delta] = 1\n      control_dw = 1\n\n      while (!is.null(test_suit) &&\n             correct_effect_ind[delta] && # as long as we can get one wrong effect, then stop\n             control_dw <= length(test_suit) # stop if we run out of the test sute\n      ) {\n\n        # stop condition: encounter an incorrect sign OR run out of test suit\n\n        test_i = test_suit[[control_dw]]\n\n        if ( is.null(test_i$Monoton_to_Match)) test_i$Monoton_to_Match = 1\n        if ( is.null(test_i$Reverse)) test_i$Reverse = FALSE\n\n        # if (trace){\n        #   if (!is.null(test_i$focus_var_coeff) ) {\n        #     cat(\"\\ncheck marginal effects of coeff vars: \", paste(test_i$focus_var_coeff,collapse = '+',sep=''))\n        #   } else {\n        #     cat(\"\\ncheck marginal effects of raw vars: \", paste(test_i$focus_var_raw,collapse = '+',sep=''))\n        #   }\n        # }\n\n        # formula(new_model)\n        new_model =\n          deleting_wrongeffect (new_model,\n                                Reverse =  test_i$Reverse,\n                                family = family,\n                                Monoton_to_Match = test_i$Monoton_to_Match,\n                                re_estimate = FALSE,\n\n                                focus_var_raw = test_i$focus_var_raw,\n                                focus_var_model = test_i$focus_var_model,\n\n                                focus_var_coeff = test_i$focus_var_coeff,\n\n                                PRINT =  FALSE,\n                                data = data, STOP = STOP,\n\n                                focus_value = test_i$focus_value,\n                                nonfocus_value = test_i$nonfocus_value,\n\n                                transform_y = test_i$transform_y,\n                                bar_plot =  test_i$bar_plot\n\n                                )\n        #\n        #\n        # eval_arguments(\n        #   deleting_wrongeffect (new_model,\n        #                         Reverse =  test_i$Reverse,\n        #                         family = family,\n        #                         Monoton_to_Match = test_i$Monoton_to_Match,\n        #                         re_estimate = FALSE,\n        #\n        #                         focus_var_raw = test_i$focus_var_raw,\n        #                         focus_var_coeff = test_i$focus_var_coeff,\n        #\n        #                         PRINT =  FALSE,\n        #                         data = data, STOP = STOP,\n        #\n        #                         focus_var_model = test_i$focus_var_model,\n        #                         focus_value = test_i$focus_value,\n        #                         nonfocus_value = test_i$nonfocus_value,\n        #\n        #                         transform_y = test_i$transform_y,\n        #                         bar_plot =  test_i$bar_plot\n        #\n        #   )\n        # )\n\n        if (!is.null(new_model$correct_effect_ind)) correct_effect_ind[delta] = new_model$correct_effect_ind\n        control_dw = control_dw + 1\n      }\n\n      #_________________________________________________________\n\n      # record\n      nvar[delta] = length(get_x(new_model,data = data, method = \"model\"))\n      IC[delta] = extractAIC(new_model,k = k)[2]\n    }\n\n    # to record\n    result = data.frame(IC, nvar , step_count, correct_effect_ind, formula_new,stringsAsFactors = FALSE)\n    result = result[order(result$IC),]\n\n    if (trace) {\n      cat(\"\\n\")\n      if (!is.null(test_suit)) {\n        print(result[,c('IC','nvar','step_count','correct_effect_ind')])\n      } else {\n        print(result[,c('IC','nvar','step_count')])\n      }\n      cat(\"\\n\\n\")\n    }\n\n    # this is the best model you choose this step: largest IC within those models with correct impacts\n\n    x_best_row = result[result$correct_effect_ind>0,][1,]\n\n    if (is.na(x_best_row$correct_effect_ind) ||\n        nrow(x_best_row) ==0 ||\n        (x_best_row$correct_effect_ind) ==0\n    ) stop(\"cannot find the correct specification according to the test suit\")\n\n    if (rownames(x_best_row) == 'origin'){   # if the best model is the original model, then stop\n      step_count = 1000\n\n      # print(deparse(formula(best_model),500))\n    } else {  # if the best model is a new model, then we create a new x_start from the best model\n      step_count = step_count + 1\n      x_start = get_x(as.formula(x_best_row$formula_new),data = data, method = \"model\")\n\n      if (trace & STOP)  Enter_to_Continue()\n\n\n      # print(best_model)\n      # print(x_start)\n\n      # rownames(x_best_row) %>% str_replace(x_best,pattern = fixed(\"+ \"),\"\")\n    }\n  }\n\n  return(best_model)\n\n\n  if (FALSE && TRUE){\n\n    # starting model:\n    # can have a dirty formula like below\n\n    set.seed(413)\n    traing_data = ggplot2::diamonds[runif(nrow(ggplot2::diamonds))<0.05,]\n    nrow(traing_data)\n\n    diamond_lm3 = lm(formula = price ~ cut + carat - cut   , data = traing_data)\n\n    scope = list(lower = price ~ 1,\n                 upper = price ~  I(carat^2) + I(carat^3) + I(carat * depth) + depth + carat)\n\n    # traditional stepwise regression with no marginal effect check\n    model1 = stepwise2(model = diamond_lm3, scope = scope,k = 2,\n                       trace = TRUE, data = traing_data, STOP = TRUE)\n    model1\n    # result is exactly same using the default step() function.\n    model2 = suppressWarnings(step(diamond_lm3,scope = scope, k = 2))\n    model2\n\n\n    #__ How to Specify the Correct Marginal Effects in Stepwise Regression  __\n\n    # this test_suit means we will check the marginal effect of both 'carat' and 'depth'\n    # for 'carat', we will only focus on 4 coeff vars :\n        # \"I(carat^3)\",\"I(carat*depth)\",\"I(carat^2)\",\"carat\"\n    # for 'depth', as we do not specify any particular coeff vars there,\n    # we will check all coeff var related to 'depth'\n\n    test_suit = list(\n      carat = list(\n        # the list name must be the raw var\n        focus_var_raw = \"carat\",\n        # must specify the focus_var_raw (see deleting_wrongeffect() ) as the raw var\n        focus_var_coeff = c(\"I(carat^3)\",\"I(carat*depth)\",\n                            \"I(carat^2)\",\"carat\") ,\n        # optional # If not defined, then we to check all coeffs related to the raw var\n        focus_value =list(carat = seq(0.5,6,0.1)),\n        Monoton_to_Match = 1 # optional. Default is 1\n      ),\n      depth = list(\n        focus_var_raw = \"depth\",\n        Monoton_to_Match = 1\n      )\n    )\n\n    model3 =  stepwise2(model = diamond_lm3, scope = scope, trace = TRUE,\n                        data = traing_data,\n                        STOP = FALSE, test_suit = test_suit)\n\n    # see the difference from model1\n    effect(model3,focus_var_raw =  \"carat\", focus_value =list(carat = seq(0.5,6,0.1)))\n\n  }\n\n}\n\n\n\n\n",
    "created" : 1467688423486.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2472048532",
    "id" : "98210FDA",
    "lastKnownWriteTime" : 1467689603,
    "last_content_update" : 1467689603667,
    "path" : "~/Dropbox/Tech/R/linear_tools_origin.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}